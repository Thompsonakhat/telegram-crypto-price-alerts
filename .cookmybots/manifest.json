{
  "projectId": "be818571-5d34-4609-ae28-4cf16dcfa395",
  "commands": [
    {
      "command": "/alert",
      "description": "Adds or removes a price alert.",
      "usage": "/alert add BTC above 70000 | /alert add ETH below 2000 | /alert remove <alertId>",
      "examples": [
        "User: /alert add BTC above 70000 → Bot: Alert created: 3f9a12c1",
        "User: /alert remove 65d4b2f3c9a0f0c2f91d8a11 → Bot: Alert removed."
      ],
      "example": "User: /alert add BTC above 70000 → Bot: Alert created: 3f9a12c1",
      "notes": "Alerts trigger once and are kept as history by marking status=triggered."
    },
    {
      "command": "/alerts",
      "description": "Lists your alerts and provides inline remove buttons.",
      "usage": "/alerts",
      "examples": [
        "User: /alerts → Bot: alert list with short ids + remove buttons"
      ],
      "example": "User: /alerts → Bot: alert list with short ids + remove buttons",
      "notes": "Requires MONGODB_URI."
    },
    {
      "command": "/help",
      "description": "Shows all commands with examples and explains polling-based alert behavior.",
      "usage": "/help",
      "examples": [
        "User: /help → Bot: command list + examples"
      ],
      "example": "User: /help → Bot: command list + examples",
      "notes": "Matches the implemented public commands."
    },
    {
      "command": "/price",
      "description": "Fetches current USD price and 24h percent change for a symbol and shows inline actions.",
      "usage": "/price BTC",
      "examples": [
        "User: /price BTC → Bot: price + change + buttons"
      ],
      "example": "User: /price BTC → Bot: price + change + buttons",
      "notes": "If the market API is down, the bot replies with a consistent fallback message (or cached data if available)."
    },
    {
      "command": "/reset",
      "description": "Clears your watchlist and alerts.",
      "usage": "/reset",
      "examples": [
        "User: /reset → Bot: Done. Your watchlist and alerts were cleared."
      ],
      "example": "User: /reset → Bot: Done. Your watchlist and alerts were cleared.",
      "notes": "Requires MONGODB_URI."
    },
    {
      "command": "/start",
      "description": "Welcome message plus inline menu for Price Lookup, Watchlist, Alerts, and Help.",
      "usage": "/start",
      "examples": [
        "User: /start → Bot: Welcome message + buttons"
      ],
      "example": "User: /start → Bot: Welcome message + buttons",
      "notes": "If MONGODB_URI is not set, the bot will mention that watchlists and alerts are disabled."
    },
    {
      "command": "/watchlist",
      "description": "Lists or updates your watchlist.",
      "usage": "/watchlist | /watchlist add BTC | /watchlist remove BTC",
      "examples": [
        "User: /watchlist → Bot: list of symbols + remove buttons",
        "User: /watchlist add ETH → Bot: confirmed + updated list"
      ],
      "example": "User: /watchlist → Bot: list of symbols + remove buttons",
      "notes": "Requires MONGODB_URI."
    }
  ],
  "aiMessages": [
    {
      "role": "user",
      "content": "Build a Telegram crypto price + alerts bot:\n\n- Watchlist: add/remove coins and list watchlist.\n- Price lookup: /price <symbol> (returns price + 24h change).\n- Alerts: set above/below alerts per coin; list and remove alerts.\n- Notifications: alert users when targets are hit.\n- Reliability: caching, graceful errors, and “API down” fallback message.\n- UX: quick inline buttons for common actions (Add alert, Remove, Watchlist)."
    },
    {
      "role": "assistant",
      "content": "Created a new grammY Telegram bot project for crypto price lookup, watchlists, and polling-based alerts with inline-button UX. Added MongoDB persistence (users/watchlists/alerts), a CoinGecko market data service with caching and stale fallback, an in-process alert poller that groups checks by symbol and triggers notifications once, plus production-safe logging and DOCS/.env.sample.\n\nFiles touched (28): .env.sample, DOCS.md, README.md, package.json, project.json, src/bot.js…\nValidation: ✅ project passes syntax/basic checks after this edit."
    }
  ],
  "createdBy": "695397c85603fcac4c8ea626",
  "source": "ai-cold-start",
  "description": "",
  "platform": "telegram",
  "planMarkdown": "Bot: Telegram Crypto Price + Alerts Bot (grammY, Node.js ESM) — Production-Ready System Plan\n\nSummary:\nA single-process Telegram bot that lets users look up crypto prices, manage a personal watchlist, and configure above/below price alerts per coin. The bot periodically checks prices from an external market-data API and sends notifications when alert conditions are met.\n\nThe plan emphasizes reliability (caching, rate limiting, graceful degradation when APIs are down), good UX (inline buttons for common actions, clear formatting, and guided flows), and maintainability (clean separation of concerns, MongoDB persistence, idempotent alert triggering, and observable operations).\n\nProduct goals:\nPrimary user goals\n\n1) Fast price lookup: Users can request /price BTC and instantly receive the current price and 24h change.\n2) Personal watchlist: Users can maintain a list of coins they care about and retrieve it quickly.\n3) Price alerts: Users can set alerts like BTC above 70000 or ETH below 3000 and be notified when thresholds are crossed.\n4) Low-friction UX: Inline buttons reduce typing; bot responses include quick next actions (Add alert, Remove, Watchlist).\n\nProduct principles\n\n1) Correctness over completeness: Prefer a smaller set of reliably supported symbols over trying to resolve every ambiguous ticker.\n2) Predictable alerts: Alerts should trigger once per condition hit and avoid spam during volatility.\n3) Transparent reliability: When upstream APIs fail, return a clear fallback message and keep bot responsive.\n4) Minimal user configuration: Default currency (e.g., USD) and sane defaults for alert behavior; allow customization later.\n\nScope boundaries (v1)\n\n1) Not a trading bot; no orders, wallets, or sensitive user keys.\n2) No complex technical indicators; only spot price and 24h change.\n3) Alerts are based on spot price threshold crossing, not candles or time windows.\n\nHigh-level architecture:\nHigh-level architecture (single Node.js process)\n\n1) Telegram interaction layer (grammY)\n   1) Command handlers: /start, /price, /watchlist, /alerts, etc.\n   2) Callback query handlers for inline buttons.\n   3) Input parsing and validation (symbols, prices).\n\n2) Domain services\n   1) MarketDataService: fetches prices and 24h change, normalizes data, handles symbol mapping.\n   2) WatchlistService: add/remove/list watchlist entries.\n   3) AlertsService: create/list/delete alerts; evaluate alerts against prices; manage alert state to prevent duplicate notifications.\n   4) NotificationService: sends messages; handles failures (blocked bot, chat not found) and updates user status.\n\n3) Persistence (MongoDB)\n   1) Users, watchlists, alerts, symbol registry (optional), and operational state needed for alert triggering.\n\n4) Caching and rate control (in-process)\n   1) Short-lived cache for price lookups to reduce API calls (e.g., 10–30 seconds per symbol).\n   2) In-flight request de-duplication per symbol (avoid concurrent fetch storms).\n   3) Global throttling for upstream API calls.\n\n5) Scheduler (in-process loop)\n   1) Periodic alert evaluation job (e.g., every 15–30 seconds; configurable).\n   2) Batching strategy: compute unique symbols needed by active alerts, fetch prices in batches when supported by the provider, then evaluate all alerts.\n\nOperational lifecycle\n\n1) Bot starts, connects to MongoDB, initializes grammY, registers handlers.\n2) Scheduler starts after successful initialization.\n3) Health and readiness checks are exposed internally (for the host environment) and logged.\n\nFailure isolation\n\n1) Upstream API failure must not crash the bot. Errors are caught and turned into:\n   1) User-facing fallback response for /price.\n   2) Skipped alert cycle with backoff for scheduler.\n2) Telegram send failures are handled per message; persistent failures mark user as unreachable to reduce retries.\n\nSymbol resolution strategy\n\n1) Maintain a canonical internal coinId (string) separate from user-entered symbol.\n2) Use a deterministic mapping table for popular symbols (BTC, ETH, SOL, etc.).\n3) When ambiguous (e.g., multiple assets share a symbol), the bot responds with a disambiguation prompt via inline buttons. Store the resolved mapping per user preference to reduce future ambiguity.\n\nData model:\nMongoDB collections (suggested)\n\n1) users\n   1) id: ObjectId\n   2) telegramUserId: number (unique)\n   3) chatId: number (for direct messages; for groups store per chat usage if supported)\n   4) locale: string (optional)\n   5) defaultFiat: string (e.g., USD)\n   6) createdAt, updatedAt\n   7) status:\n      1) active | blocked | unreachable\n      2) lastSendErrorAt, lastSendErrorReason\n\n2) watchlists\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) items: array of\n      1) coinId: string\n      2) symbol: string (display)\n      3) addedAt: date\n   4) updatedAt\n   Notes:\n   1) Alternatively store as separate documents per item for easier indexing; for v1 array is fine if sizes remain small.\n\n3) alerts\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) coinId: string (indexed)\n   4) symbol: string (display)\n   5) direction: above | below\n   6) targetPrice: number\n   7) fiat: string (e.g., USD)\n   8) status: active | triggered | paused\n   9) createdAt, updatedAt\n   10) triggeredAt: date (nullable)\n   11) lastEvaluatedAt: date (optional)\n   12) lastKnownPrice: number (optional)\n   13) triggerPolicy:\n       1) once (default) or repeat\n       2) if repeat: cooldownSeconds\n   Rationale:\n   1) Storing lastKnownPrice enables crossing detection (trigger only when crossing occurs, not merely staying above).\n\n4) coinregistry (optional but recommended)\n   1) coinId: string (unique)\n   2) primarySymbol: string\n   3) name: string\n   4) aliases: array of strings\n   5) providerIdentifiers: object (per market data provider)\n   6) updatedAt\n   Notes:\n   1) Can be curated for top coins and extended later; not mandatory for v1 if provider supports direct symbol query.\n\nIndexes\n\n1) users: unique index on telegramUserId\n2) alerts: compound index on status + coinId (for fast retrieval of active alerts grouped by symbol)\n3) alerts: index on telegramUserId (for list operations)\n4) watchlists: index on telegramUserId\n\nIn-memory structures (non-persistent)\n\n1) priceCache: Map keyed by coinId+fiat with value {price, change24h, fetchedAt, expiresAt}\n2) inflightFetches: Map keyed by coinId+fiat to Promise-like tracking to deduplicate\n3) schedulerState: lastRunAt, consecutiveFailures, backoffUntil\n\nKey flows:\n1) /start onboarding\n\n1) Create or update user record (telegramUserId, chatId).\n2) Send a welcome message with:\n   1) How to use /price\n   2) How to add alerts\n   3) Inline buttons: Price, Watchlist, Alerts\n\n2) Price lookup: /price <symbol>\n\n1) Parse input symbol; normalize (trim, uppercase).\n2) Resolve to coinId:\n   1) If exact match in coin registry, proceed.\n   2) If ambiguous, return a list of options via inline buttons.\n   3) If unknown, return a helpful error and suggest examples.\n3) Fetch market data:\n   1) Check cache (fresh within TTL). If present, use it.\n   2) Else call MarketDataService with retry policy (limited) and timeout.\n4) Reply with formatted result:\n   1) Price in defaultFiat\n   2) 24h change (percentage)\n   3) Last updated timestamp\n   4) Inline buttons: Add alert (above/below), Add to watchlist, View alerts for this coin\n5) If API fails:\n   1) Reply with fallback message: market data temporarily unavailable; suggest trying again.\n   2) Optionally show the last cached value if it exists but is stale, clearly marked as stale.\n\n3) Watchlist management\n\nA) Add: /watchlistadd <symbol> (and inline button Add to watchlist)\n1) Resolve symbol to coinId (same as /price).\n2) Upsert watchlist item; avoid duplicates.\n3) Confirm and show watchlist summary with inline actions.\n\nB) Remove: /watchlistremove <symbol> (and inline button Remove)\n1) Resolve symbol.\n2) Remove if present.\n3) Confirm outcome (removed or not found).\n\nC) List: /watchlist\n1) Load watchlist items.\n2) Optionally fetch current prices for items:\n   1) Batch fetch unique coinIds with caching.\n   2) Show a compact list with price and 24h change.\n3) Provide inline buttons per item: Price, Add alert, Remove.\n\n4) Alerts management\n\nA) Create: /alert <symbol> <above|below> <price>\n1) Parse and validate numeric target price.\n2) Resolve symbol to coinId.\n3) Create alert with status active and default triggerPolicy once.\n4) Reply with confirmation and inline buttons:\n   1) List alerts\n   2) Remove this alert\n   3) View price\n\nB) Guided creation via inline buttons\n1) User taps Add alert from a price message.\n2) Bot prompts:\n   1) Choose direction (above/below) via buttons.\n   2) Enter target price (free text).\n3) Validate and create alert.\n\nC) List: /alerts\n1) Load alerts for user.\n2) Group by coin and show status (active/triggered).\n3) Inline buttons for each alert: Remove, Pause/Resume (optional), View price.\n\nD) Remove: /alertremove <id> or via inline button\n1) Validate ownership (telegramUserId matches).\n2) Delete or mark as deleted.\n3) Confirm.\n\n5) Notification cycle (scheduler)\n\n1) Every interval, load active alerts (status=active).\n2) Determine unique coinIds needed; fetch prices (batch when possible).\n3) For each alert evaluate condition:\n   1) Above: currentPrice >= targetPrice\n   2) Below: currentPrice <= targetPrice\n4) Anti-spam and correctness:\n   1) Default behavior triggers once then marks triggered.\n   2) Optional crossing logic: if lastKnownPrice exists, only trigger when crossing the threshold from the other side.\n   3) Record triggeredAt and status update.\n5) Send notification:\n   1) Message includes coin, current price, target, and quick actions (Remove, Add another alert, View price).\n   2) Handle send errors; if blocked/unreachable, set user status accordingly.\n6) Persist updates (alert status, lastKnownPrice).\n\n6) Resilience and fallback behaviors\n\n1) If market data API is down during /price:\n   1) Respond quickly with a user-friendly error.\n   2) Optionally include stale cached value if available.\n2) If API is down during scheduler:\n   1) Skip evaluation cycle.\n   2) Increase backoff and log the incident.\n3) If MongoDB is temporarily unavailable:\n   1) Commands that require persistence return a degraded-mode message.\n   2) Price lookup may still work using in-memory cache only.\n4) Telegram rate limits:\n   1) NotificationService batches or throttles sends.\n   2) Avoid sending multiple alerts in one second to the same chat; combine messages when many alerts trigger simultaneously.\n\nTech stack:\nRuntime and framework\n\n1) Node.js (ESM) single service/process.\n2) grammY for Telegram bot API integration.\n3) Environment configuration via process environment variables, including TELEGRAMBOTTOKEN.\n\nPersistence\n\n1) MongoDB for durable storage of users, watchlists, and alerts.\n2) In-memory maps for short-lived caching and in-flight request deduplication.\n\nExternal integration\n\n1) One primary market data API provider (HTTP-based) that supports:\n   1) Spot price per coin in a fiat currency\n   2) 24h change\n   3) Optional batch queries\n2) Optional secondary provider as fallback if allowed; otherwise provide a clear API-down message.\n\nStorage\n\n1) No file storage is required for core features.\n2) If later adding charts or snapshots, store generated images in object storage or simple filesystem storage.\n\nDeployment\n\n1) Run as a Node.js server in the cloud.\n2) Use long polling or webhook mode depending on hosting capabilities; both remain within a single process.\n\nOperational tooling (within the same service)\n\n1) Structured logging (request/command context, correlation ids for updates).\n2) Basic internal metrics counters (in-memory) for:\n   1) /price requests\n   2) API successes/failures\n   3) alerts evaluated and triggered\n   4) Telegram send failures\n3) Health endpoints or health logging for readiness/liveness (implementation depends on hosting).\n\nNon-functional requirements:\nReliability\n\n1) Timeouts on all upstream HTTP calls; fail fast.\n2) Retries with jitter for transient failures (bounded, small count).\n3) Cache responses briefly to reduce load and improve latency.\n4) Scheduler backoff on repeated upstream failures.\n\nCorrectness and alert semantics\n\n1) Alerts are idempotent: once triggered, they are marked triggered to prevent repeats.\n2) Optional crossing detection reduces false triggers when an alert is created while already beyond target.\n3) All comparisons use consistent numeric parsing and rounding strategy; display rounding is separate from evaluation precision.\n\nPerformance\n\n1) Batch price fetching for alert evaluation.\n2) Avoid N+1 database calls by preloading active alerts and grouping them.\n3) Keep watchlists small by design; if large lists are allowed later, switch to per-item documents.\n\nSecurity and abuse prevention\n\n1) Input validation for symbols and target prices.\n2) Basic per-user rate limiting in memory to prevent spam (commands per minute).\n3) Do not log sensitive user content beyond what is required for debugging.\n4) Handle group chats carefully (optional in v1). If enabled, store alerts per chatId and ensure admin-only management if desired.\n\nObservability and operations\n\n1) Log all failures with actionable context (provider status, HTTP status, latency).\n2) Track alert trigger outcomes and Telegram send errors.\n3) Provide an admin-only command set for basic diagnostics (counts, last API error, scheduler status).\n\nUX and accessibility\n\n1) Consistent message format with compact numbers and clear timestamps.\n2) Inline buttons for common next steps:\n   1) Add alert above/below\n   2) Add/remove watchlist\n   3) List alerts\n3) Clear error messages with examples.\n\nData retention\n\n1) Keep triggered alerts for a limited time for user visibility, then optionally auto-archive/delete.\n2) Allow users to delete alerts and watchlist items at any time.\n\nTesting strategy (system-level plan)\n\n1) Unit test domain services (symbol resolution, alert evaluation, caching behavior).\n2) Integration test MongoDB operations for alerts and watchlists.\n3) End-to-end test key Telegram flows with simulated updates.\n4) Load test scheduler logic with many alerts to validate batching and rate limiting.\n\nBot commands:\n• /start — Initialize the bot, save your user profile, and show quick help with buttons. (usage: /start) [Onboarding]\n• /help — Show usage instructions and examples for prices, watchlists, and alerts. (usage: /help) [Onboarding]\n• /price — Get current price and 24h change for a symbol, with quick actions to add alerts or watchlist. (usage: /price <symbol>) [Market Data]\n• /watchlist — List your watchlist, optionally including current prices and 24h change, with per-coin actions. (usage: /watchlist) [Watchlist]\n• /watchlistadd — Add a coin to your watchlist. (usage: /watchlistadd <symbol>) [Watchlist]\n• /watchlistremove — Remove a coin from your watchlist. (usage: /watchlistremove <symbol>) [Watchlist]\n• /alerts — List all your alerts with status and quick buttons to remove or view price. (usage: /alerts) [Alerts]\n• /alert — Create a price threshold alert for a coin (above or below). (usage: /alert <symbol> <above|below> <targetPrice>) [Alerts]\n• /alertremove — Remove an alert by its id (or use inline buttons from /alerts). (usage: /alertremove <alertId>) [Alerts]\n• /status — Show basic bot status, including whether market data is currently available (admin-only). (usage: /status) [Admin]\n",
  "planSections": {
    "productGoals": "Primary user goals\n\n1) Fast price lookup: Users can request /price BTC and instantly receive the current price and 24h change.\n2) Personal watchlist: Users can maintain a list of coins they care about and retrieve it quickly.\n3) Price alerts: Users can set alerts like BTC above 70000 or ETH below 3000 and be notified when thresholds are crossed.\n4) Low-friction UX: Inline buttons reduce typing; bot responses include quick next actions (Add alert, Remove, Watchlist).\n\nProduct principles\n\n1) Correctness over completeness: Prefer a smaller set of reliably supported symbols over trying to resolve every ambiguous ticker.\n2) Predictable alerts: Alerts should trigger once per condition hit and avoid spam during volatility.\n3) Transparent reliability: When upstream APIs fail, return a clear fallback message and keep bot responsive.\n4) Minimal user configuration: Default currency (e.g., USD) and sane defaults for alert behavior; allow customization later.\n\nScope boundaries (v1)\n\n1) Not a trading bot; no orders, wallets, or sensitive user keys.\n2) No complex technical indicators; only spot price and 24h change.\n3) Alerts are based on spot price threshold crossing, not candles or time windows.",
    "highLevelArchitecture": "High-level architecture (single Node.js process)\n\n1) Telegram interaction layer (grammY)\n   1) Command handlers: /start, /price, /watchlist, /alerts, etc.\n   2) Callback query handlers for inline buttons.\n   3) Input parsing and validation (symbols, prices).\n\n2) Domain services\n   1) MarketDataService: fetches prices and 24h change, normalizes data, handles symbol mapping.\n   2) WatchlistService: add/remove/list watchlist entries.\n   3) AlertsService: create/list/delete alerts; evaluate alerts against prices; manage alert state to prevent duplicate notifications.\n   4) NotificationService: sends messages; handles failures (blocked bot, chat not found) and updates user status.\n\n3) Persistence (MongoDB)\n   1) Users, watchlists, alerts, symbol registry (optional), and operational state needed for alert triggering.\n\n4) Caching and rate control (in-process)\n   1) Short-lived cache for price lookups to reduce API calls (e.g., 10–30 seconds per symbol).\n   2) In-flight request de-duplication per symbol (avoid concurrent fetch storms).\n   3) Global throttling for upstream API calls.\n\n5) Scheduler (in-process loop)\n   1) Periodic alert evaluation job (e.g., every 15–30 seconds; configurable).\n   2) Batching strategy: compute unique symbols needed by active alerts, fetch prices in batches when supported by the provider, then evaluate all alerts.\n\nOperational lifecycle\n\n1) Bot starts, connects to MongoDB, initializes grammY, registers handlers.\n2) Scheduler starts after successful initialization.\n3) Health and readiness checks are exposed internally (for the host environment) and logged.\n\nFailure isolation\n\n1) Upstream API failure must not crash the bot. Errors are caught and turned into:\n   1) User-facing fallback response for /price.\n   2) Skipped alert cycle with backoff for scheduler.\n2) Telegram send failures are handled per message; persistent failures mark user as unreachable to reduce retries.\n\nSymbol resolution strategy\n\n1) Maintain a canonical internal coinId (string) separate from user-entered symbol.\n2) Use a deterministic mapping table for popular symbols (BTC, ETH, SOL, etc.).\n3) When ambiguous (e.g., multiple assets share a symbol), the bot responds with a disambiguation prompt via inline buttons. Store the resolved mapping per user preference to reduce future ambiguity.",
    "dataModel": "MongoDB collections (suggested)\n\n1) users\n   1) id: ObjectId\n   2) telegramUserId: number (unique)\n   3) chatId: number (for direct messages; for groups store per chat usage if supported)\n   4) locale: string (optional)\n   5) defaultFiat: string (e.g., USD)\n   6) createdAt, updatedAt\n   7) status:\n      1) active | blocked | unreachable\n      2) lastSendErrorAt, lastSendErrorReason\n\n2) watchlists\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) items: array of\n      1) coinId: string\n      2) symbol: string (display)\n      3) addedAt: date\n   4) updatedAt\n   Notes:\n   1) Alternatively store as separate documents per item for easier indexing; for v1 array is fine if sizes remain small.\n\n3) alerts\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) coinId: string (indexed)\n   4) symbol: string (display)\n   5) direction: above | below\n   6) targetPrice: number\n   7) fiat: string (e.g., USD)\n   8) status: active | triggered | paused\n   9) createdAt, updatedAt\n   10) triggeredAt: date (nullable)\n   11) lastEvaluatedAt: date (optional)\n   12) lastKnownPrice: number (optional)\n   13) triggerPolicy:\n       1) once (default) or repeat\n       2) if repeat: cooldownSeconds\n   Rationale:\n   1) Storing lastKnownPrice enables crossing detection (trigger only when crossing occurs, not merely staying above).\n\n4) coinregistry (optional but recommended)\n   1) coinId: string (unique)\n   2) primarySymbol: string\n   3) name: string\n   4) aliases: array of strings\n   5) providerIdentifiers: object (per market data provider)\n   6) updatedAt\n   Notes:\n   1) Can be curated for top coins and extended later; not mandatory for v1 if provider supports direct symbol query.\n\nIndexes\n\n1) users: unique index on telegramUserId\n2) alerts: compound index on status + coinId (for fast retrieval of active alerts grouped by symbol)\n3) alerts: index on telegramUserId (for list operations)\n4) watchlists: index on telegramUserId\n\nIn-memory structures (non-persistent)\n\n1) priceCache: Map keyed by coinId+fiat with value {price, change24h, fetchedAt, expiresAt}\n2) inflightFetches: Map keyed by coinId+fiat to Promise-like tracking to deduplicate\n3) schedulerState: lastRunAt, consecutiveFailures, backoffUntil",
    "keyFlows": "1) /start onboarding\n\n1) Create or update user record (telegramUserId, chatId).\n2) Send a welcome message with:\n   1) How to use /price\n   2) How to add alerts\n   3) Inline buttons: Price, Watchlist, Alerts\n\n2) Price lookup: /price <symbol>\n\n1) Parse input symbol; normalize (trim, uppercase).\n2) Resolve to coinId:\n   1) If exact match in coin registry, proceed.\n   2) If ambiguous, return a list of options via inline buttons.\n   3) If unknown, return a helpful error and suggest examples.\n3) Fetch market data:\n   1) Check cache (fresh within TTL). If present, use it.\n   2) Else call MarketDataService with retry policy (limited) and timeout.\n4) Reply with formatted result:\n   1) Price in defaultFiat\n   2) 24h change (percentage)\n   3) Last updated timestamp\n   4) Inline buttons: Add alert (above/below), Add to watchlist, View alerts for this coin\n5) If API fails:\n   1) Reply with fallback message: market data temporarily unavailable; suggest trying again.\n   2) Optionally show the last cached value if it exists but is stale, clearly marked as stale.\n\n3) Watchlist management\n\nA) Add: /watchlistadd <symbol> (and inline button Add to watchlist)\n1) Resolve symbol to coinId (same as /price).\n2) Upsert watchlist item; avoid duplicates.\n3) Confirm and show watchlist summary with inline actions.\n\nB) Remove: /watchlistremove <symbol> (and inline button Remove)\n1) Resolve symbol.\n2) Remove if present.\n3) Confirm outcome (removed or not found).\n\nC) List: /watchlist\n1) Load watchlist items.\n2) Optionally fetch current prices for items:\n   1) Batch fetch unique coinIds with caching.\n   2) Show a compact list with price and 24h change.\n3) Provide inline buttons per item: Price, Add alert, Remove.\n\n4) Alerts management\n\nA) Create: /alert <symbol> <above|below> <price>\n1) Parse and validate numeric target price.\n2) Resolve symbol to coinId.\n3) Create alert with status active and default triggerPolicy once.\n4) Reply with confirmation and inline buttons:\n   1) List alerts\n   2) Remove this alert\n   3) View price\n\nB) Guided creation via inline buttons\n1) User taps Add alert from a price message.\n2) Bot prompts:\n   1) Choose direction (above/below) via buttons.\n   2) Enter target price (free text).\n3) Validate and create alert.\n\nC) List: /alerts\n1) Load alerts for user.\n2) Group by coin and show status (active/triggered).\n3) Inline buttons for each alert: Remove, Pause/Resume (optional), View price.\n\nD) Remove: /alertremove <id> or via inline button\n1) Validate ownership (telegramUserId matches).\n2) Delete or mark as deleted.\n3) Confirm.\n\n5) Notification cycle (scheduler)\n\n1) Every interval, load active alerts (status=active).\n2) Determine unique coinIds needed; fetch prices (batch when possible).\n3) For each alert evaluate condition:\n   1) Above: currentPrice >= targetPrice\n   2) Below: currentPrice <= targetPrice\n4) Anti-spam and correctness:\n   1) Default behavior triggers once then marks triggered.\n   2) Optional crossing logic: if lastKnownPrice exists, only trigger when crossing the threshold from the other side.\n   3) Record triggeredAt and status update.\n5) Send notification:\n   1) Message includes coin, current price, target, and quick actions (Remove, Add another alert, View price).\n   2) Handle send errors; if blocked/unreachable, set user status accordingly.\n6) Persist updates (alert status, lastKnownPrice).\n\n6) Resilience and fallback behaviors\n\n1) If market data API is down during /price:\n   1) Respond quickly with a user-friendly error.\n   2) Optionally include stale cached value if available.\n2) If API is down during scheduler:\n   1) Skip evaluation cycle.\n   2) Increase backoff and log the incident.\n3) If MongoDB is temporarily unavailable:\n   1) Commands that require persistence return a degraded-mode message.\n   2) Price lookup may still work using in-memory cache only.\n4) Telegram rate limits:\n   1) NotificationService batches or throttles sends.\n   2) Avoid sending multiple alerts in one second to the same chat; combine messages when many alerts trigger simultaneously.",
    "techStack": "Runtime and framework\n\n1) Node.js (ESM) single service/process.\n2) grammY for Telegram bot API integration.\n3) Environment configuration via process environment variables, including TELEGRAMBOTTOKEN.\n\nPersistence\n\n1) MongoDB for durable storage of users, watchlists, and alerts.\n2) In-memory maps for short-lived caching and in-flight request deduplication.\n\nExternal integration\n\n1) One primary market data API provider (HTTP-based) that supports:\n   1) Spot price per coin in a fiat currency\n   2) 24h change\n   3) Optional batch queries\n2) Optional secondary provider as fallback if allowed; otherwise provide a clear API-down message.\n\nStorage\n\n1) No file storage is required for core features.\n2) If later adding charts or snapshots, store generated images in object storage or simple filesystem storage.\n\nDeployment\n\n1) Run as a Node.js server in the cloud.\n2) Use long polling or webhook mode depending on hosting capabilities; both remain within a single process.\n\nOperational tooling (within the same service)\n\n1) Structured logging (request/command context, correlation ids for updates).\n2) Basic internal metrics counters (in-memory) for:\n   1) /price requests\n   2) API successes/failures\n   3) alerts evaluated and triggered\n   4) Telegram send failures\n3) Health endpoints or health logging for readiness/liveness (implementation depends on hosting).",
    "nonFunctional": "Reliability\n\n1) Timeouts on all upstream HTTP calls; fail fast.\n2) Retries with jitter for transient failures (bounded, small count).\n3) Cache responses briefly to reduce load and improve latency.\n4) Scheduler backoff on repeated upstream failures.\n\nCorrectness and alert semantics\n\n1) Alerts are idempotent: once triggered, they are marked triggered to prevent repeats.\n2) Optional crossing detection reduces false triggers when an alert is created while already beyond target.\n3) All comparisons use consistent numeric parsing and rounding strategy; display rounding is separate from evaluation precision.\n\nPerformance\n\n1) Batch price fetching for alert evaluation.\n2) Avoid N+1 database calls by preloading active alerts and grouping them.\n3) Keep watchlists small by design; if large lists are allowed later, switch to per-item documents.\n\nSecurity and abuse prevention\n\n1) Input validation for symbols and target prices.\n2) Basic per-user rate limiting in memory to prevent spam (commands per minute).\n3) Do not log sensitive user content beyond what is required for debugging.\n4) Handle group chats carefully (optional in v1). If enabled, store alerts per chatId and ensure admin-only management if desired.\n\nObservability and operations\n\n1) Log all failures with actionable context (provider status, HTTP status, latency).\n2) Track alert trigger outcomes and Telegram send errors.\n3) Provide an admin-only command set for basic diagnostics (counts, last API error, scheduler status).\n\nUX and accessibility\n\n1) Consistent message format with compact numbers and clear timestamps.\n2) Inline buttons for common next steps:\n   1) Add alert above/below\n   2) Add/remove watchlist\n   3) List alerts\n3) Clear error messages with examples.\n\nData retention\n\n1) Keep triggered alerts for a limited time for user visibility, then optionally auto-archive/delete.\n2) Allow users to delete alerts and watchlist items at any time.\n\nTesting strategy (system-level plan)\n\n1) Unit test domain services (symbol resolution, alert evaluation, caching behavior).\n2) Integration test MongoDB operations for alerts and watchlists.\n3) End-to-end test key Telegram flows with simulated updates.\n4) Load test scheduler logic with many alerts to validate batching and rate limiting."
  },
  "runStatuses": {
    "be818571-5d34-4609-ae28-4cf16dcfa395:mm42nzrv:vuouc6": {
      "phase": "done",
      "stage": "cold_start",
      "runId": "be818571-5d34-4609-ae28-4cf16dcfa395:mm42nzrv:vuouc6",
      "lastUserMessage": "Build a Telegram crypto price + alerts bot:\n\n- Watchlist: add/remove coins and list watchlist.\n- Price lookup: /price <symbol> (returns price + 24h change).\n- Alerts: set above/below alerts per coin; list and remove alerts.\n- Notifications: alert users when targets are hit.\n- Reliability: caching, graceful errors, and “API down” fallback message.\n- UX: quick inline buttons for common actions (Add alert, Remove, Watchlist).",
      "startedAt": "2026-02-26T23:06:04.899Z",
      "updatedAt": "2026-02-26T23:09:36.856Z",
      "message": "GitHub auto-push skipped (no repo linked or GitHub not connected in session).",
      "commands": [
        {
          "name": "alert",
          "file": "src/commands/alert.js"
        },
        {
          "name": "alerts",
          "file": "src/commands/alerts.js"
        },
        {
          "name": "help",
          "file": "src/commands/help.js"
        },
        {
          "name": "menu",
          "file": "src/commands/menu.js"
        },
        {
          "name": "price",
          "file": "src/commands/price.js"
        },
        {
          "name": "reset",
          "file": "src/commands/reset.js"
        },
        {
          "name": "start",
          "file": "src/commands/start.js"
        },
        {
          "name": "togglewatchlist",
          "file": "src/commands/toggleWatchlist.js"
        },
        {
          "name": "watchlist",
          "file": "src/commands/watchlist.js"
        }
      ],
      "ok": true,
      "state": {
        "projectId": "be818571-5d34-4609-ae28-4cf16dcfa395",
        "fileStructure": {
          ".env.sample": {
            "type": "file",
            "content": "# Telegram\nTELEGRAM_BOT_TOKEN=\n\n# MongoDB (recommended for persistence)\nMONGODB_URI=\n\n# Market data provider\n# Default is CoinGecko v3 API\nCOIN_API_BASE_URL=https://api.coingecko.com/api/v3\n\n# Caching (ms)\nCACHE_TTL_MS=30000\n\n# Alert poller (ms)\nPOLL_INTERVAL_MS=45000\n\n# Logging\nLOG_LEVEL=info\n"
          },
          "CHANGELOG.md": {
            "type": "file",
            "content": "# Changelog\n\nAll notable changes to this bot project are recorded here.\n\n## 2026-02-26 23:09:36. UTC\n- Request: Build a Telegram crypto price + alerts bot: - Watchlist: add/remove coins and list watchlist. - Price lookup: /price <symbol> (returns price + 24h change). - Alerts: set above/below alerts per coin; list and remove aler…\n- Summary: Created a new grammY Telegram bot project for crypto price lookup, watchlists, and polling-based alerts with inline-button UX. Added MongoDB persistence (users/watchlists/alerts), a CoinGecko market data service with ca…\n- Files: .env.sample, DOCS.md, README.md, package.json, project.json, src/bot.js, src/commands/alert.js, src/commands/alerts.js, src/commands/help.js, src/commands/loader.js, src/commands/menu.js, src/commands/price.js, src/commands/reset.js, src/commands/start.js (+1…\n\n"
          },
          "DOCS.md": {
            "type": "file",
            "content": "What this bot does\nThis Telegram bot lets you look up crypto prices, keep a watchlist, and set price alerts that notify you when a coin goes above or below a target price.\n\nPublic commands\n1) /start\nShows a welcome message and a menu with inline buttons.\n\n2) /help\nShows usage examples for prices, watchlists, and alerts.\n\n3) /price <symbol>\nExample: /price BTC\nReplies with current price in USD, 24h percent change, and a timestamp. Includes inline buttons to add alerts and manage your watchlist.\n\n4) /watchlist\nLists your saved symbols. Shows latest cached prices when available. Includes inline remove buttons.\n\n5) /watchlist add <symbol>\nExample: /watchlist add ETH\nAdds the symbol to your watchlist.\n\n6) /watchlist remove <symbol>\nExample: /watchlist remove ETH\nRemoves the symbol from your watchlist.\n\n7) /alerts\nLists your alerts with id, symbol, direction, target, and status. Includes inline remove buttons.\n\n8) /alert add <symbol> above <price>\nExample: /alert add BTC above 70000\nCreates an alert that triggers when current price is greater than or equal to the target.\n\n9) /alert add <symbol> below <price>\nExample: /alert add ETH below 2000\nCreates an alert that triggers when current price is less than or equal to the target.\n\n10) /alert remove <alertId>\nExample: /alert remove 3f9a12c1\nDeletes the alert.\n\n11) /reset\nClears your watchlist and alerts.\n\nInline buttons\n1) Price Lookup: prompts you to use /price <symbol>\n2) My Watchlist: opens your watchlist\n3) My Alerts: opens your alerts\n4) Add Alert ↑ / Add Alert ↓: starts an interactive flow. The bot asks you to send the target price next.\n5) Add to Watchlist / Remove from Watchlist: toggles watchlist membership\n6) Remove alert: deletes the selected alert\n\nAlert behavior\n1) Alerts are polling-based, so notifications may be delayed up to the polling interval.\n2) Alerts trigger once and are kept for history by marking status=triggered and triggeredAt.\n3) If the market data provider is down, the poller logs the error and continues on the next cycle.\n\nMarket data provider\nDefault provider is CoinGecko.\n1) Base URL is configurable via COIN_API_BASE_URL.\n2) Prices are cached per symbol for CACHE_TTL_MS to reduce rate-limited calls.\n3) If the API fails and a cached value exists, the bot may show cached data with a stale note.\n\nEnvironment variables\n1) TELEGRAM_BOT_TOKEN (required)\n2) MONGODB_URI (recommended for persistence)\n3) COIN_API_BASE_URL (optional, default https://api.coingecko.com/api/v3)\n4) CACHE_TTL_MS (optional, default 30000)\n5) POLL_INTERVAL_MS (optional, default 45000)\n6) LOG_LEVEL (optional, default info)\n\nDatabase collections\n1) users: { telegramUserId, createdAt, updatedAt }\n2) watchlists: { telegramUserId, symbols:[\"BTC\"], createdAt, updatedAt }\n3) alerts: { telegramUserId, symbol, direction:\"above\"|\"below\", target:Number, status:\"active\"|\"triggered\", triggeredAt?, createdAt, updatedAt }\n"
          },
          "README.md": {
            "type": "file",
            "content": "This is a Telegram bot (grammY) for crypto price lookup, watchlists, and polling-based price alerts.\n\nFeatures\n1) /price BTC shows current USD price and 24h change\n2) Watchlist: /watchlist, /watchlist add BTC, /watchlist remove BTC\n3) Alerts: /alerts, /alert add BTC above 70000, /alert remove <alertId>\n4) Inline buttons for common actions (add/remove watchlist, remove alerts, start add-alert flow)\n5) Reliability: caching, grouping alert checks by symbol, graceful API-down fallback\n\nArchitecture\n1) src/index.js: boot, env sanity, long polling runner, webhook cleanup\n2) src/bot.js: grammY wiring, command registration, callbacks, interactive flows\n3) src/services/marketData.js: CoinGecko market data + caching\n4) src/services/watchlists.js: Mongo watchlist operations\n5) src/services/alerts.js: Mongo alert operations + evaluation helpers\n6) src/jobs/alertPoller.js: polling loop that triggers notifications\n7) src/lib/db.js: Mongo singleton and indexes\n8) src/lib/log.js: structured, production-safe logs + safeErr()\n\nSetup\n1) Create a Telegram bot token with BotFather.\n2) Copy .env.sample to .env and fill values.\n3) Install deps: npm run install:root\n4) Run locally: npm run dev\n\nEnvironment variables\n1) TELEGRAM_BOT_TOKEN (required): Telegram bot token\n2) MONGODB_URI (optional but recommended): MongoDB connection string for users/watchlists/alerts\n3) COIN_API_BASE_URL (optional): market data base URL (default: https://api.coingecko.com/api/v3)\n4) CACHE_TTL_MS (optional): price cache ttl (default: 30000)\n5) POLL_INTERVAL_MS (optional): alert polling interval (default: 45000)\n6) LOG_LEVEL (optional): debug|info|warn|error (default: info)\n\nCommands (examples)\n1) /start\n2) /help\n3) /price BTC\n4) /watchlist\n5) /watchlist add BTC\n6) /watchlist remove BTC\n7) /alerts\n8) /alert add BTC above 70000\n9) /alert add ETH below 2000\n10) /alert remove <alertId>\n11) /reset (clear your stored watchlist and alerts)\n\nDeployment notes (Render)\n1) Use a Background Worker (or any always-on Node service).\n2) Set TELEGRAM_BOT_TOKEN.\n3) Set MONGODB_URI for persistence.\n4) Build command should run: npm run build\n5) Start command: npm start\n\nTroubleshooting\n1) If the bot starts but doesn’t respond, verify TELEGRAM_BOT_TOKEN is set.\n2) If alerts don’t trigger, check logs for poller cycles and market API failures.\n3) If market API is down, /price will return a consistent fallback message.\n"
          },
          "package.json": {
            "type": "file",
            "content": "{\n  \"name\": \"cookmybots-telegram-bot\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"scripts\": {\n    \"install:root\": \"bash -lc \\\"set -e; if [ -f package-lock.json ]; then npm ci; else npm install; fi\\\"\",\n    \"build\": \"npm run install:root && echo build\",\n    \"start\": \"node src/index.js\",\n    \"dev\": \"node --watch src/index.js\"\n  },\n  \"dependencies\": {\n    \"dotenv\": \"^16.4.5\",\n    \"grammy\": \"^1.20.0\",\n    \"mongodb\": \"^6.10.0\",\n    \"@grammyjs/runner\": \"^2.0.3\"\n  },\n  \"devDependencies\": {}\n}\n"
          },
          "src": {
            "type": "dir",
            "children": {
              "bot.js": {
                "type": "file",
                "content": "import { Bot } from \"grammy\";\nimport { maybeHandleAlertFlowMessage } from \"./features/alertFlow.js\";\n\nexport function createBot(token, deps) {\n  const bot = new Bot(token);\n\n  bot.on(\"message:text\", async (ctx, next) => {\n    const raw = String(ctx.message?.text || \"\");\n    if (raw.startsWith(\"/\")) return next();\n\n    const handled = await maybeHandleAlertFlowMessage(ctx, deps);\n    if (handled) return;\n\n    return next();\n  });\n\n  return bot;\n}\n"
              },
              "commands": {
                "type": "dir",
                "children": {
                  "alert.js": {
                    "type": "file",
                    "content": "import { createAlert, normalizeDirection, parseTargetPrice, removeAlert } from \"../services/alerts.js\";\nimport { startAlertFlow } from \"../features/alertFlow.js\";\n\nexport default function register(bot, { cfg, log }) {\n  bot.command(\"alert\", async (ctx) => {\n    const userId = ctx.from?.id;\n    if (!cfg.MONGODB_URI) {\n      await ctx.reply(\"Alerts need a database connection. The bot is running in limited mode right now.\");\n      return;\n    }\n    if (!userId) {\n      await ctx.reply(\"I couldn’t identify your user id.\");\n      return;\n    }\n\n    const parts = String(ctx.match || \"\").trim().split(/\\s+/).filter(Boolean);\n    const sub = String(parts[0] || \"\").toLowerCase();\n\n    if (sub === \"add\") {\n      const symbol = String(parts[1] || \"\").trim().toUpperCase();\n      const direction = normalizeDirection(parts[2]);\n      const target = parseTargetPrice(parts[3]);\n\n      if (!symbol || !direction || !target) {\n        await ctx.reply(\"Usage: /alert add BTC above 70000\\nOr: /alert add ETH below 2000\");\n        return;\n      }\n\n      const r = await createAlert({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol, direction, target });\n      if (!r.ok) {\n        await ctx.reply(\"Sorry, I couldn’t create that alert. Please try again.\");\n        return;\n      }\n\n      await ctx.reply(`Alert created: ${String(r.id).slice(0, 8)}`);\n      return;\n    }\n\n    if (sub === \"remove\") {\n      const id = String(parts[1] || \"\").trim();\n      if (!id) {\n        await ctx.reply(\"Usage: /alert remove <alertId>\");\n        return;\n      }\n      const r = await removeAlert({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, alertId: id });\n      if (!r.ok) {\n        await ctx.reply(\"I couldn’t remove that alert. Check the id and try again.\");\n        return;\n      }\n      await ctx.reply(r.removed ? \"Alert removed.\" : \"Alert not found.\");\n      return;\n    }\n\n    await ctx.reply(\"Usage:\\n/alert add BTC above 70000\\n/alert add ETH below 2000\\n/alert remove <alertId>\");\n  });\n\n  bot.callbackQuery(/^aa:([A-Z0-9]{1,15}):(above|below)$/, async (ctx) => {\n    const userId = ctx.from?.id;\n    await ctx.answerCallbackQuery();\n    if (!userId) return;\n\n    const symbol = String(ctx.match?.[1] || \"\").trim().toUpperCase();\n    const direction = String(ctx.match?.[2] || \"\").trim().toLowerCase();\n\n    if (!cfg.MONGODB_URI) {\n      await ctx.reply(\"Alerts need a database connection.\");\n      return;\n    }\n\n    startAlertFlow({ userId, symbol, direction });\n    await ctx.reply(`Send target price for ${symbol} (${direction}).\\nExample: 70000\\n\\nYou can type cancel to stop.`);\n  });\n}\n"
                  },
                  "alerts.js": {
                    "type": "file",
                    "content": "import { InlineKeyboard } from \"grammy\";\nimport { listAlerts, removeAlert } from \"../services/alerts.js\";\nimport { fmtUsd, shortId } from \"../lib/format.js\";\n\nexport default function register(bot, { cfg, log }) {\n  bot.command(\"alerts\", async (ctx) => {\n    const userId = ctx.from?.id;\n    if (!cfg.MONGODB_URI) {\n      await ctx.reply(\"Alerts need a database connection. The bot is running in limited mode right now.\");\n      return;\n    }\n    if (!userId) {\n      await ctx.reply(\"I couldn’t identify your user id.\");\n      return;\n    }\n\n    const r = await listAlerts({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId });\n    if (!r.ok) {\n      await ctx.reply(\"Sorry, I couldn’t load your alerts right now.\");\n      return;\n    }\n\n    if (r.alerts.length === 0) {\n      await ctx.reply(\"You have no alerts. Example: /alert add BTC above 70000\");\n      return;\n    }\n\n    const lines = [\"Your alerts:\"];\n    const kb = new InlineKeyboard();\n\n    for (const a of r.alerts.slice(0, 30)) {\n      const created = a.createdAt ? new Date(a.createdAt).toLocaleString() : \"\";\n      const t = `${shortId(a.id)} | ${a.symbol} ${a.direction} ${fmtUsd(a.target)} | ${a.status}${created ? \" | \" + created : \"\"}`;\n      lines.push(t);\n      kb.text(`Remove ${shortId(a.id)}`, `ar:${a.id}`).row();\n    }\n\n    await ctx.reply(lines.join(\"\\n\"), { reply_markup: kb });\n  });\n\n  bot.callbackQuery(/^ar:([a-f0-9]{24})$/, async (ctx) => {\n    const userId = ctx.from?.id;\n    await ctx.answerCallbackQuery();\n\n    if (!cfg.MONGODB_URI || !userId) {\n      await ctx.reply(\"Alerts need a database connection.\");\n      return;\n    }\n\n    const alertId = ctx.match?.[1];\n    const r = await removeAlert({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, alertId });\n    if (!r.ok) {\n      await ctx.reply(\"I couldn’t remove that alert. It may already be gone.\");\n      return;\n    }\n\n    await ctx.reply(r.removed ? \"Alert removed.\" : \"Alert not found.\");\n  });\n}\n"
                  },
                  "help.js": {
                    "type": "file",
                    "content": "export default function register(bot) {\n  bot.command(\"help\", async (ctx) => {\n    await ctx.reply(\n      [\n        \"Commands and examples:\",\n        \"/price BTC\",\n        \"/watchlist\",\n        \"/watchlist add BTC\",\n        \"/watchlist remove BTC\",\n        \"/alerts\",\n        \"/alert add BTC above 70000\",\n        \"/alert add ETH below 2000\",\n        \"/alert remove <alertId>\",\n        \"\",\n        \"Alerts are polling-based. A notification is sent when the target is hit, and it can be delayed by the polling interval.\",\n      ].join(\"\\n\")\n    );\n  });\n}\n"
                  },
                  "loader.js": {
                    "type": "file",
                    "content": "import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { fileURLToPath, pathToFileURL } from \"node:url\";\n\nexport async function registerCommands(bot, deps = {}) {\n  const dir = path.dirname(fileURLToPath(import.meta.url));\n\n  const commandFiles = fs\n    .readdirSync(dir)\n    .filter((file) => file.endsWith(\".js\") && file !== \"loader.js\" && !file.startsWith(\"_\"))\n    .sort();\n\n  for (const file of commandFiles) {\n    const modUrl = pathToFileURL(path.join(dir, file)).href;\n    const mod = await import(modUrl);\n\n    const handler = mod?.default || mod?.register;\n    if (typeof handler === \"function\") {\n      await handler(bot, deps);\n    } else {\n      console.warn(\"[commands] skipped\", { file });\n    }\n  }\n}\n"
                  },
                  "menu.js": {
                    "type": "file",
                    "content": "export default function register(bot) {\n  bot.callbackQuery(/^menu:(price|watchlist|alerts|help)$/, async (ctx) => {\n    const which = ctx.match?.[1];\n    await ctx.answerCallbackQuery();\n\n    if (which === \"price\") {\n      await ctx.reply(\"Send /price <symbol> مثلا: /price BTC\");\n      return;\n    }\n    if (which === \"watchlist\") {\n      await ctx.reply(\"Send /watchlist to view your watchlist.\");\n      return;\n    }\n    if (which === \"alerts\") {\n      await ctx.reply(\"Send /alerts to view your alerts.\");\n      return;\n    }\n    if (which === \"help\") {\n      await ctx.reply(\"Send /help to see all commands.\");\n      return;\n    }\n  });\n}\n"
                  },
                  "price.js": {
                    "type": "file",
                    "content": "import { InlineKeyboard } from \"grammy\";\nimport { fmtUsd, fmtPct } from \"../lib/format.js\";\nimport { hasInWatchlist } from \"../services/watchlists.js\";\n\nconst API_DOWN_FALLBACK = \"Market data is temporarily unavailable. Please try again later.\";\n\nfunction normalizeSymbol(symbol) {\n  return String(symbol || \"\").trim().toUpperCase();\n}\n\nexport default function register(bot, { cfg, log, market }) {\n  bot.command(\"price\", async (ctx) => {\n    const userId = ctx.from?.id;\n    const raw = ctx.match;\n    const sym = normalizeSymbol(raw);\n\n    if (!sym) {\n      await ctx.reply(\"Usage: /price BTC\");\n      return;\n    }\n\n    const q = await market.getQuoteBySymbol(sym, { allowStale: true });\n\n    if (!q.ok) {\n      if (q.reason === \"unknown_symbol\") {\n        await ctx.reply(`I don’t recognize the symbol ${sym}. Try something like BTC, ETH, or SOL.`);\n        return;\n      }\n      await ctx.reply(API_DOWN_FALLBACK);\n      return;\n    }\n\n    let watch = { ok: false, has: false };\n    if (cfg.MONGODB_URI && userId) {\n      watch = await hasInWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n    }\n\n    const staleNote = q.stale ? \"\\n\\nNote: showing cached data (API may be down).\" : \"\";\n    const ts = q.ts ? new Date(q.ts) : new Date();\n\n    const lines = [\n      `${q.name || sym} (${sym})`,\n      `Price: ${fmtUsd(q.priceUsd)}`,\n      `24h: ${q.change24hPct == null ? \"N/A\" : fmtPct(q.change24hPct)}`,\n      `As of: ${ts.toLocaleString()}`,\n    ];\n\n    const kb = new InlineKeyboard();\n    kb.text(\"Add Alert ↑\", `aa:${sym}:above`).text(\"Add Alert ↓\", `aa:${sym}:below`).row();\n\n    if (cfg.MONGODB_URI && userId) {\n      kb.text(watch.ok && watch.has ? \"Remove from Watchlist\" : \"Add to Watchlist\", `wt:${sym}`).row();\n    }\n\n    kb.text(\"View Watchlist\", \"menu:watchlist\").text(\"View Alerts\", \"menu:alerts\");\n\n    await ctx.reply(lines.join(\"\\n\") + staleNote, { reply_markup: kb });\n  });\n\n  bot.callbackQuery(/^px:([A-Z0-9]{1,15})$/, async (ctx) => {\n    const sym = normalizeSymbol(ctx.match?.[1]);\n    await ctx.answerCallbackQuery();\n    await ctx.reply(`/price ${sym}`);\n  });\n}\n"
                  },
                  "reset.js": {
                    "type": "file",
                    "content": "import { clearWatchlist } from \"../services/watchlists.js\";\nimport { clearAlerts } from \"../services/alerts.js\";\n\nexport default function register(bot, { cfg, log }) {\n  bot.command(\"reset\", async (ctx) => {\n    const userId = ctx.from?.id;\n    if (!cfg.MONGODB_URI) {\n      await ctx.reply(\"Nothing to reset because MONGODB_URI is not set.\");\n      return;\n    }\n    if (!userId) {\n      await ctx.reply(\"I couldn’t identify your user id.\");\n      return;\n    }\n\n    await clearWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId });\n    await clearAlerts({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId });\n\n    await ctx.reply(\"Done. Your watchlist and alerts were cleared.\");\n  });\n}\n"
                  },
                  "start.js": {
                    "type": "file",
                    "content": "import { InlineKeyboard } from \"grammy\";\nimport { upsertUser } from \"../services/users.js\";\n\nexport default function register(bot, { cfg, log }) {\n  bot.command(\"start\", async (ctx) => {\n    const userId = ctx.from?.id;\n    const chatId = ctx.chat?.id;\n\n    if (userId) {\n      await upsertUser({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, chatId });\n    }\n\n    const kb = new InlineKeyboard()\n      .text(\"Price Lookup\", \"menu:price\").row()\n      .text(\"My Watchlist\", \"menu:watchlist\").row()\n      .text(\"My Alerts\", \"menu:alerts\").row()\n      .text(\"Help\", \"menu:help\");\n\n    const extra = cfg.MONGODB_URI ? \"\" : \"\\n\\nNote: MONGODB_URI is not set, so watchlists and alerts are disabled.\";\n\n    await ctx.reply(\n      \"Welcome. I can look up crypto prices, manage a watchlist, and send price alerts.\\n\\nSymbols are simple tickers like BTC or ETH. Prices come from a market data provider.\" + extra,\n      { reply_markup: kb }\n    );\n  });\n}\n"
                  },
                  "toggleWatchlist.js": {
                    "type": "file",
                    "content": "import { addToWatchlist, removeFromWatchlist, hasInWatchlist } from \"../services/watchlists.js\";\n\nfunction normalizeSymbol(symbol) {\n  return String(symbol || \"\").trim().toUpperCase();\n}\n\nexport default function register(bot, { cfg, log }) {\n  bot.callbackQuery(/^wt:([A-Z0-9]{1,15})$/, async (ctx) => {\n    const userId = ctx.from?.id;\n    const sym = normalizeSymbol(ctx.match?.[1]);\n    await ctx.answerCallbackQuery();\n\n    if (!cfg.MONGODB_URI || !userId) {\n      await ctx.reply(\"Watchlists need a database connection.\");\n      return;\n    }\n\n    const h = await hasInWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n    if (h.ok && h.has) {\n      await removeFromWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n      await ctx.reply(`Removed ${sym} from your watchlist.`);\n      return;\n    }\n\n    await addToWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n    await ctx.reply(`Added ${sym} to your watchlist.`);\n  });\n}\n"
                  },
                  "watchlist.js": {
                    "type": "file",
                    "content": "import { InlineKeyboard } from \"grammy\";\nimport { getWatchlist, addToWatchlist, removeFromWatchlist, clearWatchlist } from \"../services/watchlists.js\";\nimport { fmtUsd, fmtPct } from \"../lib/format.js\";\n\nfunction normalizeSymbol(symbol) {\n  return String(symbol || \"\").trim().toUpperCase();\n}\n\nexport default function register(bot, { cfg, log, market }) {\n  bot.command(\"watchlist\", async (ctx) => {\n    const userId = ctx.from?.id;\n    if (!cfg.MONGODB_URI) {\n      await ctx.reply(\"Watchlists need a database connection. The bot is running in limited mode right now.\");\n      return;\n    }\n    if (!userId) {\n      await ctx.reply(\"I couldn’t identify your user id.\");\n      return;\n    }\n\n    const parts = String(ctx.match || \"\").trim().split(/\\s+/).filter(Boolean);\n    const sub = String(parts[0] || \"\").toLowerCase();\n\n    if (sub === \"add\") {\n      const sym = normalizeSymbol(parts[1]);\n      if (!sym) {\n        await ctx.reply(\"Usage: /watchlist add BTC\");\n        return;\n      }\n      const r = await addToWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n      if (!r.ok) {\n        await ctx.reply(\"Sorry, I couldn’t update your watchlist. Please try again.\");\n        return;\n      }\n      await ctx.reply(`Added ${sym} to your watchlist.`);\n      await showWatchlist(ctx, { cfg, log, market, userId });\n      return;\n    }\n\n    if (sub === \"remove\") {\n      const sym = normalizeSymbol(parts[1]);\n      if (!sym) {\n        await ctx.reply(\"Usage: /watchlist remove BTC\");\n        return;\n      }\n      const r = await removeFromWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n      if (!r.ok) {\n        await ctx.reply(\"Sorry, I couldn’t update your watchlist. Please try again.\");\n        return;\n      }\n      await ctx.reply(`Removed ${sym} from your watchlist.`);\n      await showWatchlist(ctx, { cfg, log, market, userId });\n      return;\n    }\n\n    await showWatchlist(ctx, { cfg, log, market, userId });\n  });\n\n  bot.callbackQuery(/^wr:([A-Z0-9]{1,15})$/, async (ctx) => {\n    const userId = ctx.from?.id;\n    const sym = normalizeSymbol(ctx.match?.[1]);\n    await ctx.answerCallbackQuery();\n\n    if (!cfg.MONGODB_URI || !userId) {\n      await ctx.reply(\"Watchlists need a database connection.\");\n      return;\n    }\n\n    await removeFromWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n    await ctx.reply(`Removed ${sym} from your watchlist.`);\n  });\n\n  bot.callbackQuery(/^wc$/, async (ctx) => {\n    const userId = ctx.from?.id;\n    await ctx.answerCallbackQuery();\n\n    if (!cfg.MONGODB_URI || !userId) {\n      await ctx.reply(\"Watchlists need a database connection.\");\n      return;\n    }\n\n    await clearWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId });\n    await ctx.reply(\"Watchlist cleared.\");\n  });\n}\n\nasync function showWatchlist(ctx, { cfg, log, market, userId }) {\n  const wl = await getWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId });\n  if (!wl.ok) {\n    await ctx.reply(\"Sorry, I couldn’t load your watchlist right now.\");\n    return;\n  }\n\n  if (wl.symbols.length === 0) {\n    await ctx.reply(\"Your watchlist is empty. Add one with /watchlist add BTC.\");\n    return;\n  }\n\n  const quotes = await market.getQuotesForSymbols(wl.symbols);\n\n  const lines = [\"Your watchlist:\"];\n  for (const sym of wl.symbols) {\n    const q = quotes.get(sym);\n    if (q?.ok) {\n      const change = q.change24hPct == null ? \"\" : ` (${fmtPct(q.change24hPct)})`;\n      const stale = q.stale ? \" [cached]\" : \"\";\n      lines.push(`${sym}: ${fmtUsd(q.priceUsd)}${change}${stale}`);\n    } else {\n      lines.push(`${sym}: (no data right now)`);\n    }\n  }\n\n  const kb = new InlineKeyboard();\n  for (const sym of wl.symbols.slice(0, 20)) {\n    kb.text(`Remove ${sym}`, `wr:${sym}`).row();\n  }\n  kb.text(\"Clear\", \"wc\");\n\n  await ctx.reply(lines.join(\"\\n\"), { reply_markup: kb });\n}\n"
                  }
                }
              },
              "features": {
                "type": "dir",
                "children": {
                  "alertFlow.js": {
                    "type": "file",
                    "content": "import { parseTargetPrice, createAlert } from \"../services/alerts.js\";\n\nconst TTL_MS = 120_000;\n\nconst flows = new Map();\n\nfunction now() {\n  return Date.now();\n}\n\nfunction keyFor(userId) {\n  return String(userId || \"\");\n}\n\nexport function startAlertFlow({ userId, symbol, direction }) {\n  const k = keyFor(userId);\n  flows.set(k, {\n    symbol: String(symbol || \"\").trim().toUpperCase(),\n    direction: String(direction || \"\").trim().toLowerCase(),\n    expiresAt: now() + TTL_MS,\n  });\n}\n\nexport function clearAlertFlow(userId) {\n  flows.delete(keyFor(userId));\n}\n\nexport function getAlertFlow(userId) {\n  const k = keyFor(userId);\n  const f = flows.get(k);\n  if (!f) return null;\n  if (f.expiresAt <= now()) {\n    flows.delete(k);\n    return null;\n  }\n  return f;\n}\n\nexport async function maybeHandleAlertFlowMessage(ctx, { mongoUri, log }) {\n  const userId = ctx.from?.id;\n  if (!userId) return false;\n\n  const f = getAlertFlow(userId);\n  if (!f) return false;\n\n  const text = String(ctx.message?.text || \"\").trim();\n  if (!text) return true;\n\n  if (/^(cancel|stop|never mind|nevermind)$/i.test(text)) {\n    clearAlertFlow(userId);\n    await ctx.reply(\"Cancelled. If you want to add an alert, use /alert add BTC above 70000 or tap Add Alert from a price message.\");\n    return true;\n  }\n\n  const target = parseTargetPrice(text);\n  if (!target) {\n    await ctx.reply(`Please send a valid number for the target price (USD), or type cancel.`);\n    return true;\n  }\n\n  clearAlertFlow(userId);\n\n  const created = await createAlert({\n    mongoUri,\n    log,\n    telegramUserId: userId,\n    symbol: f.symbol,\n    direction: f.direction,\n    target,\n  });\n\n  if (!created.ok) {\n    if (created.reason === \"no_db\") {\n      await ctx.reply(\"Alerts need a database connection. The bot is running in limited mode right now.\");\n      return true;\n    }\n    await ctx.reply(\"Sorry, I couldn’t create that alert. Please try again.\");\n    return true;\n  }\n\n  const idShort = String(created.id).slice(0, 8);\n  await ctx.reply(`Alert created: ${idShort}\\n${f.symbol} ${f.direction} ${target}`);\n  return true;\n}\n"
                  }
                }
              },
              "index.js": {
                "type": "file",
                "content": "import \"dotenv/config\";\n\nimport { run } from \"@grammyjs/runner\";\n\nimport { cfg } from \"./lib/config.js\";\nimport { createLogger, safeErr } from \"./lib/log.js\";\nimport { createBot } from \"./bot.js\";\nimport { registerCommands } from \"./commands/loader.js\";\nimport { getDb, closeDb } from \"./lib/db.js\";\nimport { MarketDataService } from \"./services/marketData.js\";\nimport { startAlertPoller } from \"./jobs/alertPoller.js\";\nimport { buildBotProfile } from \"./lib/botProfile.js\";\n\nprocess.on(\"unhandledRejection\", (r) => {\n  console.error(\"UnhandledRejection:\", r);\n  process.exit(1);\n});\nprocess.on(\"uncaughtException\", (e) => {\n  console.error(\"UncaughtException:\", e);\n  process.exit(1);\n});\n\nasync function boot() {\n  const log = createLogger({ level: cfg.LOG_LEVEL });\n\n  log.info(\"boot start\", {\n    nodeEnv: process.env.NODE_ENV || \"\",\n    TELEGRAM_BOT_TOKEN_set: !!cfg.TELEGRAM_BOT_TOKEN,\n    MONGODB_URI_set: !!cfg.MONGODB_URI,\n    COIN_API_BASE_URL_set: !!cfg.COIN_API_BASE_URL,\n  });\n\n  if (!cfg.TELEGRAM_BOT_TOKEN) {\n    console.error(\"TELEGRAM_BOT_TOKEN is required. Add it to your env and redeploy.\");\n    process.exit(1);\n  }\n\n  const bot = createBot(cfg.TELEGRAM_BOT_TOKEN, { mongoUri: cfg.MONGODB_URI, log });\n\n  try {\n    await bot.init();\n  } catch (e) {\n    log.warn(\"bot init failed\", { err: safeErr(e) });\n  }\n\n  const db = await getDb(cfg.MONGODB_URI, log);\n  if (!db && cfg.MONGODB_URI) {\n    log.warn(\"db unavailable, running in limited mode\", { mongo: false });\n  }\n\n  const market = new MarketDataService({\n    baseUrl: cfg.COIN_API_BASE_URL,\n    cacheTtlMs: cfg.CACHE_TTL_MS,\n    log,\n  });\n\n  const botProfile = buildBotProfile();\n  log.info(\"bot profile\", { chars: botProfile.length });\n\n  await registerCommands(bot, { cfg, log, market, mongoUri: cfg.MONGODB_URI, botProfile });\n\n  try {\n    await bot.api.setMyCommands([\n      { command: \"start\", description: \"Welcome and menu\" },\n      { command: \"help\", description: \"How to use the bot\" },\n      { command: \"price\", description: \"Get price for a symbol\" },\n      { command: \"watchlist\", description: \"Manage your watchlist\" },\n      { command: \"alerts\", description: \"List your alerts\" },\n      { command: \"alert\", description: \"Add/remove an alert\" },\n      { command: \"reset\", description: \"Clear watchlist and alerts\" },\n    ]);\n  } catch (e) {\n    log.warn(\"setMyCommands failed\", { err: safeErr(e) });\n  }\n\n  let poller = null;\n\n  async function startPollingWithRetry() {\n    let delay = 2000;\n    const maxDelay = 20000;\n    let runner = null;\n\n    for (;;) {\n      try {\n        log.info(\"polling start\", { runnerConcurrency: 1 });\n\n        try {\n          await bot.api.deleteWebhook({ drop_pending_updates: true });\n        } catch (e) {\n          log.warn(\"deleteWebhook failed\", { err: safeErr(e) });\n        }\n\n        runner = run(bot, { runner: { concurrency: 1 } });\n        log.info(\"polling running\");\n\n        poller = startAlertPoller({ bot, cfg, log, market });\n\n        await runner.task();\n\n        log.warn(\"polling stopped unexpectedly, restarting\");\n      } catch (e) {\n        const msg = safeErr(e);\n        const is409 = String(msg).includes(\"409\") || String(msg).toLowerCase().includes(\"conflict\");\n        log.warn(\"polling error\", { err: msg, is409, delayMs: delay });\n      }\n\n      try {\n        poller?.stop?.();\n      } catch {}\n      poller = null;\n\n      await new Promise((r) => setTimeout(r, delay));\n      delay = Math.min(maxDelay, Math.floor(delay * 1.7));\n    }\n  }\n\n  await startPollingWithRetry();\n\n  async function shutdown() {\n    try {\n      poller?.stop?.();\n    } catch {}\n    await closeDb(log);\n  }\n\n  process.on(\"SIGINT\", () => shutdown().finally(() => process.exit(0)));\n  process.on(\"SIGTERM\", () => shutdown().finally(() => process.exit(0)));\n}\n\nboot().catch((e) => {\n  console.error(\"Boot error:\", safeErr(e));\n  process.exit(1);\n});\n"
              },
              "jobs": {
                "type": "dir",
                "children": {
                  "alertPoller.js": {
                    "type": "file",
                    "content": "import { safeErr } from \"../lib/log.js\";\nimport { loadActiveAlerts, markTriggered } from \"../services/alerts.js\";\nimport { fmtUsd } from \"../lib/format.js\";\n\nfunction sleep(ms) {\n  return new Promise((r) => setTimeout(r, ms));\n}\n\nexport function startAlertPoller({ bot, cfg, log, market }) {\n  const intervalMs = Number.isFinite(cfg.POLL_INTERVAL_MS) && cfg.POLL_INTERVAL_MS > 0 ? cfg.POLL_INTERVAL_MS : 45_000;\n\n  let stopped = false;\n  let running = false;\n  let cycles = 0;\n  let backoffMs = 0;\n\n  async function cycle() {\n    if (stopped || running) return;\n    running = true;\n    const started = Date.now();\n\n    try {\n      log.info(\"poller cycle start\", { intervalMs, backoffMs });\n\n      if (backoffMs > 0) {\n        await sleep(backoffMs);\n        backoffMs = 0;\n      }\n\n      const r = await loadActiveAlerts({ mongoUri: cfg.MONGODB_URI, log });\n      const alerts = r.ok ? r.alerts : [];\n\n      if (!r.ok) {\n        log.warn(\"poller load alerts failed\", { reason: r.reason });\n        return;\n      }\n\n      const uniqueSymbols = [...new Set(alerts.map((a) => a.symbol))];\n      const quotes = await market.getQuotesForSymbols(uniqueSymbols);\n\n      let checked = 0;\n      let triggered = 0;\n\n      for (const a of alerts) {\n        checked++;\n        const q = quotes.get(a.symbol);\n        if (!q || !q.ok) continue;\n\n        const price = q.priceUsd;\n        const hit = a.direction === \"above\" ? price >= a.target : price <= a.target;\n        if (!hit) continue;\n\n        triggered++;\n\n        try {\n          await markTriggered({ mongoUri: cfg.MONGODB_URI, log, alertId: a.id, currentPrice: price });\n\n          const idShort = String(a.id).slice(0, 8);\n          const msg = [\n            `Price alert triggered (${idShort})`,\n            `${a.symbol} is ${fmtUsd(price)}`,\n            `Target was ${a.direction} ${fmtUsd(a.target)}`,\n          ].join(\"\\n\");\n\n          await bot.api.sendMessage(Number(a.telegramUserId), msg, {\n            reply_markup: {\n              inline_keyboard: [\n                [\n                  { text: \"View Price\", callback_data: `px:${a.symbol}` },\n                  { text: \"Remove Alert\", callback_data: `ar:${a.id}` },\n                ],\n                [\n                  { text: \"New Alert ↑\", callback_data: `aa:${a.symbol}:above` },\n                  { text: \"New Alert ↓\", callback_data: `aa:${a.symbol}:below` },\n                ],\n              ],\n            },\n          });\n        } catch (e) {\n          log.warn(\"poller notify failed\", { userId: a.telegramUserId, err: safeErr(e) });\n        }\n      }\n\n      const ms = Date.now() - started;\n      log.info(\"poller cycle end\", { checked, triggered, symbols: uniqueSymbols.length, ms });\n\n      cycles++;\n      if (cycles % Math.max(1, Math.floor(60_000 / intervalMs)) === 0) {\n        const m = process.memoryUsage();\n        console.log(\"[mem]\", { rssMB: Math.round(m.rss / 1e6), heapUsedMB: Math.round(m.heapUsed / 1e6) });\n      }\n    } catch (e) {\n      log.error(\"poller cycle error\", { err: safeErr(e) });\n      backoffMs = Math.min(20_000, Math.max(2_000, (backoffMs || 2_000) * 2));\n    } finally {\n      running = false;\n    }\n  }\n\n  log.info(\"poller started\", { intervalMs });\n  const t = setInterval(() => {\n    cycle().catch((e) => log.error(\"poller tick error\", { err: safeErr(e) }));\n  }, intervalMs);\n\n  cycle().catch((e) => log.error(\"poller first cycle error\", { err: safeErr(e) }));\n\n  return {\n    stop: () => {\n      stopped = true;\n      clearInterval(t);\n      log.info(\"poller stopped\");\n    },\n  };\n}\n"
                  }
                }
              },
              "lib": {
                "type": "dir",
                "children": {
                  "ai.js": {
                    "type": "file",
                    "content": "function trimSlash(u) {\n  u = String(u || \"\");\n  while (u.endsWith(\"/\")) u = u.slice(0, -1);\n  return u;\n}\n\nfunction sleep(ms) {\n  return new Promise((r) => setTimeout(r, ms));\n}\n\nasync function safeRead(r) {\n  const text = await r.text();\n  let json = null;\n  try { json = JSON.parse(text); } catch {}\n  return { text, json };\n}\n\nfunction notConfigured(message) {\n  return { ok: false, status: 412, json: null, text: \"\", error: message };\n}\n\nfunction withTimeout(ms) {\n  const ctrl = new AbortController();\n  const t = setTimeout(() => ctrl.abort(), ms);\n  return { ctrl, clear: () => clearTimeout(t) };\n}\n\nfunction pickTimeout(cfg) {\n  const v = Number(cfg?.AI_TIMEOUT_MS || cfg?.AI_TIMEOUT || 20000);\n  return Number.isFinite(v) && v > 0 ? v : 20000;\n}\n\nfunction pickModel(cfg, override) {\n  const m = String(override || cfg?.AI_MODEL || \"\").trim();\n  return m || undefined;\n}\n\nfunction isRetryableStatus(status) {\n  // 408: request timeout, 429: rate, 500/502/503/504 transient\n  return status === 408 || status === 429 || status === 500 || status === 502 || status === 503 || status === 504;\n}\n\nfunction redact(s) {\n  s = String(s || \"\");\n  if (s.length <= 400) return s;\n  return s.slice(0, 400) + \"…\";\n}\n\nfunction web3Mode(cfg) {\n  const m = String(cfg?.WEB3_CHAT_MODE || \"auto\").trim().toLowerCase();\n  return (m === \"on\" || m === \"off\" || m === \"auto\") ? m : \"auto\";\n}\n\nasync function aiGet(cfg, path, opts = {}) {\n  const base = trimSlash(cfg?.COOKMYBOTS_AI_ENDPOINT || \"\");\n  const key = String(cfg?.COOKMYBOTS_AI_KEY || \"\");\n  const DEBUG = String(cfg?.AI_DEBUG || \"\") === \"1\";\n  if (!base || !key) return notConfigured(\"AI_NOT_CONFIGURED (missing COOKMYBOTS_AI_ENDPOINT/COOKMYBOTS_AI_KEY)\");\n\n  const timeoutMs = Number(opts.timeoutMs || pickTimeout(cfg));\n  const url = base + String(path || \"\");\n\n  const { ctrl, clear } = withTimeout(timeoutMs);\n  try {\n    if (DEBUG) console.log(\"[aiGet] ->\", url);\n    const r = await fetch(url, { method: \"GET\", headers: { Authorization: \"Bearer \" + key }, signal: ctrl.signal });\n    const { text, json } = await safeRead(r);\n    if (!r.ok) {\n      const err = json?.error || json?.message || text || \"AI_ERROR\";\n      return { ok: false, status: r.status, json, text, error: String(err) };\n    }\n    return { ok: true, status: r.status, json, text, error: null };\n  } catch (e) {\n    const msg = e?.name === \"AbortError\" ? \"AI_TIMEOUT\" : (e?.message || \"AI_NETWORK_ERROR\");\n    return { ok: false, status: e?.name === \"AbortError\" ? 408 : 0, json: null, text: \"\", error: String(msg) };\n  } finally {\n    clear();\n  }\n}\n\nasync function routeChat(cfg, userText, systemHint) {\n  // Uses the normal gateway /chat as a fast classifier.\n  // Returns: \"web3\" | \"normal\"\n  const base = trimSlash(cfg?.COOKMYBOTS_AI_ENDPOINT || \"\");\n  const key = String(cfg?.COOKMYBOTS_AI_KEY || \"\");\n  if (!base || !key) return \"normal\";\n\n  const timeoutMs = Math.min(8000, pickTimeout(cfg));\n  const { ctrl, clear } = withTimeout(timeoutMs);\n\n  const sys = [\n    \"You are a routing classifier for a bot.\",\n    \"Decide if the user's message should go to a Web3 specialist model (ChainGPT) or a normal general AI model.\",\n    \"\",\n    \"Return ONLY valid JSON:\",\n    '{\"route\":\"web3\"}',\n    \"or\",\n    '{\"route\":\"normal\"}',\n    \"\",\n    \"Route to web3 if the user asks about: crypto, tokens, Solidity, smart contracts, audits, DeFi, NFTs, wallets, chains, bridges, gas, DEXs, on-chain tools or anything related to blockchain.\",\n    \"Otherwise route to normal.\",\n    \"\",\n    \"Extra context (bot/system hint):\",\n    String(systemHint || \"\").slice(0, 800),\n  ].join(\"\n\");\n\n  try {\n    const r = await fetch(base + \"/chat\", {\n      method: \"POST\",\n      headers: {\n        Authorization: \"Bearer \" + key,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        messages: [\n          { role: \"system\", content: sys },\n          { role: \"user\", content: String(userText || \"\").slice(0, 2000) },\n        ],\n        model: pickModel(cfg, \"\"), // let gateway default or AI_MODEL\n        meta: { purpose: \"route\" },\n      }),\n      signal: ctrl.signal,\n    });\n\n    const { text, json } = await safeRead(r);\n    if (!r.ok) return \"normal\";\n\n    // Try common shapes: gateway might return {text} or OpenAI-like {choices}\n    const out =\n      (json && (json.text || json.message)) ||\n      (json && json.choices && json.choices[0] && json.choices[0].message && json.choices[0].message.content) ||\n      text ||\n      \"\";\n\n    const raw = String(out || \"\").trim();\n\n    // Parse JSON safely\n    try {\n      const obj = JSON.parse(raw);\n      const route = String(obj?.route || \"\").toLowerCase();\n      return route === \"web3\" ? \"web3\" : \"normal\";\n    } catch {\n      // If model returned non-JSON, fallback to normal\n      return \"normal\";\n    }\n  } catch {\n    return \"normal\";\n  } finally {\n    clear();\n  }\n}\n\n/**\n * Low-level gateway call.\n * Always returns: { ok, status, json, text, error }\n * - json is parsed response body (if JSON)\n * - error is a short string for logs/UI\n */\nexport async function aiCall(cfg, path, body, opts = {}) {\n  const base = trimSlash(cfg?.COOKMYBOTS_AI_ENDPOINT || \"\");\n  const key = String(cfg?.COOKMYBOTS_AI_KEY || \"\");\n  const DEBUG = String(cfg?.AI_DEBUG || \"\") === \"1\";\n\n  if (!base || !key) return notConfigured(\"AI_NOT_CONFIGURED (missing COOKMYBOTS_AI_ENDPOINT/COOKMYBOTS_AI_KEY)\");\n\n  const timeoutMs = Number(opts.timeoutMs || pickTimeout(cfg));\n  const retries = Number.isFinite(opts.retries) ? Number(opts.retries) : 1; // default 1 retry\n  const backoffMs = Number.isFinite(opts.backoffMs) ? Number(opts.backoffMs) : 750;\n\n  const url = base + String(path || \"\");\n  const started = Date.now();\n\n  let attempt = 0;\n  while (true) {\n    attempt++;\n\n    const { ctrl, clear } = withTimeout(timeoutMs);\n    try {\n      if (DEBUG) console.log(\"[aiCall] ->\", url, { attempt, timeoutMs });\n\n      const r = await fetch(url, {\n        method: \"POST\",\n        headers: {\n          Authorization: \"Bearer \" + key,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(body || {}),\n        signal: ctrl.signal,\n      });\n\n      const { text, json } = await safeRead(r);\n\n      if (!r.ok) {\n        const err = json?.error || json?.message || text || \"AI_ERROR\";\n        const out = { ok: false, status: r.status, json, text, error: String(err) };\n\n        if (DEBUG) {\n          const ms = Date.now() - started;\n          console.warn(\"[aiCall] <- fail\", { status: r.status, ms, attempt, err: redact(err) });\n        }\n\n        // Retry transient errors\n        if (attempt <= retries && isRetryableStatus(r.status)) {\n          await sleep(backoffMs * attempt);\n          continue;\n        }\n\n        return out;\n      }\n\n      if (DEBUG) {\n        const ms = Date.now() - started;\n        console.log(\"[aiCall] <- ok\", { status: r.status, ms, attempt });\n      }\n\n      return { ok: true, status: r.status, json, text, error: null };\n    } catch (e) {\n      const msg = e?.name === \"AbortError\" ? \"AI_TIMEOUT\" : (e?.message || \"AI_NETWORK_ERROR\");\n      const out = { ok: false, status: e?.name === \"AbortError\" ? 408 : 0, json: null, text: \"\", error: String(msg) };\n\n      if (DEBUG) {\n        const ms = Date.now() - started;\n        console.warn(\"[aiCall] <- exception\", { ms, attempt, err: redact(msg) });\n      }\n\n      // Retry network/timeout issues (status 0/408)\n      if (attempt <= retries) {\n        await sleep(backoffMs * attempt);\n        continue;\n      }\n\n      return out;\n    } finally {\n      clear();\n    }\n  }\n}\n\n/**\n * CHAT\n * Backward compatible:\n * 1) aiChat(cfg, \"hello\", { model, meta, system })\n * 2) aiChat(cfg, { messages:[...], model, meta })\n *\n * Returns: { ok, status, json, text, error }\n */\nexport async function aiChat(cfg, input, opts = {}) {\n  // Signature (cfg, { messages, model, meta })\n  if (input && typeof input === \"object\" && Array.isArray(input.messages)) {\n    const model = pickModel(cfg, input.model);\n    return aiCall(cfg, \"/chat\", {\n      messages: input.messages,\n      model,\n      meta: input.meta || undefined,\n    }, opts);\n  }\n\n  // Signature (cfg, \"prompt\")\n  const userText = String(input || \"\");\n  const system = String(opts.system || \"You are a helpful assistant.\");\n  const model = pickModel(cfg, opts.model);\n\n  return aiCall(cfg, \"/chat\", {\n    messages: [\n      { role: \"system\", content: system },\n      { role: \"user\", content: userText },\n    ],\n    model,\n    meta: opts.meta || undefined,\n  }, opts);\n}\n\n// IMAGE\nexport async function aiImage(cfg, { prompt, size = \"1024x1024\", n = 1, model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/image\", { prompt, size, n, model: m, meta: meta || undefined }, opts);\n}\n\n// VISION\nexport async function aiVision(cfg, { prompt, imageUrl, model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/vision\", { prompt, imageUrl, model: m, meta: meta || undefined }, opts);\n}\n\n// EMBEDDINGS\nexport async function aiEmbeddings(cfg, { input, model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/embeddings\", { input, model: m, meta: meta || undefined }, opts);\n}\n\n// WEB SEARCH\nexport async function aiWebSearch(cfg, { query, meta } = {}, opts = {}) {\n  return aiCall(cfg, \"/web-search\", { query, meta: meta || undefined }, opts);\n}\n\n// SPEECH\nexport async function aiSpeechTts(cfg, { text, voice = \"alloy\", format = \"mp3\", model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/speech/tts\", { text, voice, format, model: m, meta: meta || undefined }, opts);\n}\n\nexport async function aiSpeechStt(cfg, { audioBase64, mimeType = \"audio/mpeg\", filename = \"audio.mp3\", durationSeconds = 0, model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/speech/stt\", { audioBase64, mimeType, filename, durationSeconds, model: m, meta: meta || undefined }, opts);\n}\n\n// VIDEO\nexport async function aiVideoCreate(cfg, { prompt, seconds = 4, size = \"1024x576\", model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/video/create\", { prompt, seconds, size, model: m, meta: meta || undefined }, opts);\n}\n\n/**\n * Video status is GET in many gateways.\n * If your gateway is POST-only, you can keep it as GET via fetch() here.\n */\nexport async function aiVideoStatus(cfg, jobId, opts = {}) {\n  const base = trimSlash(cfg?.COOKMYBOTS_AI_ENDPOINT || \"\");\n  const key = String(cfg?.COOKMYBOTS_AI_KEY || \"\");\n  const DEBUG = String(cfg?.AI_DEBUG || \"\") === \"1\";\n\n  if (!base || !key) return notConfigured(\"AI_NOT_CONFIGURED (missing COOKMYBOTS_AI_ENDPOINT/COOKMYBOTS_AI_KEY)\");\n\n  const timeoutMs = Number(opts.timeoutMs || pickTimeout(cfg));\n  const url = base + \"/video/\" + encodeURIComponent(String(jobId || \"\"));\n\n  const { ctrl, clear } = withTimeout(timeoutMs);\n  try {\n    if (DEBUG) console.log(\"[aiVideoStatus] ->\", url);\n\n    const r = await fetch(url, {\n      headers: { Authorization: \"Bearer \" + key },\n      signal: ctrl.signal,\n    });\n\n    const { text, json } = await safeRead(r);\n\n    if (!r.ok) {\n      const err = json?.error || json?.message || text || \"AI_VIDEO_STATUS_ERROR\";\n      if (DEBUG) console.warn(\"[aiVideoStatus] failed:\", r.status, redact(err));\n      return { ok: false, status: r.status, json, text, error: String(err) };\n    }\n\n    return { ok: true, status: r.status, json, text, error: null };\n  } catch (e) {\n    const msg = e?.name === \"AbortError\" ? \"AI_TIMEOUT\" : (e?.message || \"AI_NETWORK_ERROR\");\n    if (DEBUG) console.warn(\"[aiVideoStatus] exception:\", redact(msg));\n    return { ok: false, status: e?.name === \"AbortError\" ? 408 : 0, json: null, text: \"\", error: String(msg) };\n  } finally {\n    clear();\n  }\n}\n\nexport async function aiChainGptChat(cfg, { mode = \"web3\", question, meta } = {}, opts = {}) {\n  const m = web3Mode(cfg);\n  if (m === \"off\") return notConfigured(\"WEB3_DISABLED (WEB3_CHAT_MODE=off)\");\n\n  // mode: \"web3\" | \"smart_contract_generator\" | \"smart_contract_auditor\"\n  return aiCall(cfg, \"/chaingpt/chat\", {\n    mode: String(mode || \"web3\"),\n    question: String(question || \"\"),\n    meta: meta || undefined,\n  }, opts);\n}\n\nexport async function aiChainGptNews(cfg, { limit = 5 } = {}, opts = {}) {\n  const m = web3Mode(cfg);\n  if (m === \"off\") return notConfigured(\"WEB3_DISABLED (WEB3_CHAT_MODE=off)\");\n  const q = Number(limit || 5);\n  const lim = Number.isFinite(q) ? Math.max(1, Math.min(q, 20)) : 5;\n  return aiGet(cfg, \"/chaingpt/news?limit=\" + encodeURIComponent(String(lim)), opts);\n}\n\nexport async function aiChainGptNftImage(cfg, { prompt, model = \"velogen\", steps = 2, width = 512, height = 512, enhance = \"1x\", meta } = {}, opts = {}) {\n  const m = web3Mode(cfg);\n  if (m === \"off\") return notConfigured(\"WEB3_DISABLED (WEB3_CHAT_MODE=off)\");\n\n  return aiCall(cfg, \"/chaingpt/nft/image\", {\n    prompt: String(prompt || \"\"),\n    model: String(model || \"velogen\"),\n    steps: Number(steps || 2),\n    width: Number(width || 512),\n    height: Number(height || 512),\n    enhance: String(enhance || \"1x\"),\n    meta: meta || undefined,\n  }, opts);\n}\n\n// Convenience: auto-route to ChainGPT if it looks web3, else normal aiChat()\nexport async function aiSmartChat(cfg, userText, { system = \"\", meta = {}, retries = 1 } = {}) {\n  const m = web3Mode(cfg);\n\n  // Forced modes\n  if (m === \"on\") {\n    return aiChainGptChat(cfg, { mode: \"web3\", question: String(userText || \"\"), meta }, { retries });\n  }\n  if (m === \"off\") {\n    return aiChat(cfg, String(userText || \"\"), { system: system || \"You are a helpful assistant.\", meta, retries });\n  }\n\n  // AUTO mode: AI decides route\n  const route = await routeChat(cfg, userText, system);\n\n  if (route === \"web3\") {\n    return aiChainGptChat(cfg, { mode: \"web3\", question: String(userText || \"\"), meta }, { retries });\n  }\n\n  return aiChat(cfg, String(userText || \"\"), { system: system || \"You are a helpful assistant.\", meta, retries });\n}\n\n"
                  },
                  "botProfile.js": {
                    "type": "file",
                    "content": "export function buildBotProfile() {\n  return [\n    \"Purpose: Crypto price lookup, personal watchlists, and polling-based price alerts with Telegram notifications.\",\n    \"Commands:\",\n    \"1) /start - Welcome + buttons for common actions\",\n    \"2) /help - Command list and examples\",\n    \"3) /price <symbol> - Current USD price and 24h change (e.g., /price BTC)\",\n    \"4) /watchlist - List watchlist\",\n    \"5) /watchlist add <symbol> - Add to watchlist\",\n    \"6) /watchlist remove <symbol> - Remove from watchlist\",\n    \"7) /alerts - List alerts\",\n    \"8) /alert add <symbol> above <price> - Create alert\",\n    \"9) /alert add <symbol> below <price> - Create alert\",\n    \"10) /alert remove <alertId> - Remove alert\",\n    \"Rules:\",\n    \"1) Alerts are polling-based so notifications can be delayed by the polling interval.\",\n    \"2) If market data is unavailable, replies use a consistent fallback message.\",\n  ].join(\"\\n\");\n}\n"
                  },
                  "config.js": {
                    "type": "file",
                    "content": "export const cfg = {\n  TELEGRAM_BOT_TOKEN: process.env.TELEGRAM_BOT_TOKEN,\n  MONGODB_URI: process.env.MONGODB_URI || \"\",\n\n  COIN_API_BASE_URL: process.env.COIN_API_BASE_URL || \"https://api.coingecko.com/api/v3\",\n\n  CACHE_TTL_MS: Number(process.env.CACHE_TTL_MS || 30_000),\n  POLL_INTERVAL_MS: Number(process.env.POLL_INTERVAL_MS || 45_000),\n\n  LOG_LEVEL: process.env.LOG_LEVEL || \"info\",\n};\n"
                  },
                  "db.js": {
                    "type": "file",
                    "content": "import { MongoClient } from \"mongodb\";\nimport { safeErr } from \"./log.js\";\n\nlet _client = null;\nlet _db = null;\nlet _initPromise = null;\n\nexport async function getDb(mongoUri, log) {\n  if (!mongoUri) return null;\n  if (_db) return _db;\n  if (_initPromise) return _initPromise;\n\n  _initPromise = (async () => {\n    try {\n      _client = new MongoClient(mongoUri, {\n        maxPoolSize: 5,\n        ignoreUndefined: true,\n      });\n      await _client.connect();\n      _db = _client.db();\n\n      if (log) log.info(\"db connected\", { mongo: true });\n\n      await ensureIndexes(_db, log);\n      return _db;\n    } catch (e) {\n      if (log) log.error(\"db connect failed\", { err: safeErr(e) });\n      _client = null;\n      _db = null;\n      _initPromise = null;\n      return null;\n    }\n  })();\n\n  return _initPromise;\n}\n\nasync function ensureIndexes(db, log) {\n  try {\n    await db.collection(\"users\").createIndex({ telegramUserId: 1 }, { unique: true });\n    await db.collection(\"watchlists\").createIndex({ telegramUserId: 1 }, { unique: true });\n    await db.collection(\"alerts\").createIndex({ telegramUserId: 1, status: 1 });\n    await db.collection(\"alerts\").createIndex({ status: 1, symbol: 1 });\n  } catch (e) {\n    if (log) log.error(\"db ensureIndexes failed\", { err: safeErr(e) });\n  }\n}\n\nexport async function closeDb(log) {\n  try {\n    if (_client) await _client.close();\n  } catch (e) {\n    if (log) log.warn(\"db close failed\", { err: safeErr(e) });\n  } finally {\n    _client = null;\n    _db = null;\n    _initPromise = null;\n  }\n}\n"
                  },
                  "format.js": {
                    "type": "file",
                    "content": "export function fmtUsd(n) {\n  if (typeof n !== \"number\" || !Number.isFinite(n)) return \"N/A\";\n  const abs = Math.abs(n);\n  const digits = abs >= 1000 ? 2 : abs >= 1 ? 4 : 6;\n  return n.toLocaleString(\"en-US\", {\n    style: \"currency\",\n    currency: \"USD\",\n    maximumFractionDigits: digits,\n  });\n}\n\nexport function fmtPct(n) {\n  if (typeof n !== \"number\" || !Number.isFinite(n)) return \"N/A\";\n  const sign = n > 0 ? \"+\" : n < 0 ? \"-\" : \"\";\n  return `${sign}${Math.abs(n).toFixed(2)}%`;\n}\n\nexport function shortId(hex) {\n  const s = String(hex || \"\");\n  return s.length <= 8 ? s : s.slice(0, 8);\n}\n"
                  },
                  "log.js": {
                    "type": "file",
                    "content": "export function safeErr(err) {\n  return (\n    err?.response?.data?.error?.message ||\n    err?.response?.data?.message ||\n    err?.message ||\n    String(err)\n  );\n}\n\nfunction levelRank(lvl) {\n  const v = String(lvl || \"info\").toLowerCase();\n  if (v === \"debug\") return 10;\n  if (v === \"info\") return 20;\n  if (v === \"warn\") return 30;\n  if (v === \"error\") return 40;\n  return 20;\n}\n\nexport function createLogger({ level = \"info\" } = {}) {\n  const min = levelRank(level);\n  const log = (lvl, msg, meta) => {\n    if (levelRank(lvl) < min) return;\n    const line = {\n      ts: new Date().toISOString(),\n      level: lvl,\n      msg,\n      ...(meta && typeof meta === \"object\" ? meta : {}),\n    };\n    const s = JSON.stringify(line);\n    if (lvl === \"error\") console.error(s);\n    else if (lvl === \"warn\") console.warn(s);\n    else console.log(s);\n  };\n\n  return {\n    debug: (msg, meta) => log(\"debug\", msg, meta),\n    info: (msg, meta) => log(\"info\", msg, meta),\n    warn: (msg, meta) => log(\"warn\", msg, meta),\n    error: (msg, meta) => log(\"error\", msg, meta),\n  };\n}\n"
                  },
                  "memory.js": {
                    "type": "file",
                    "content": "\n      import { getDb } from \"./db.js\";\n\nconst COL = \"memory_messages\";\n\nexport async function addTurn({ mongoUri, platform, userId, chatId, role, text }) {\n  const db = await getDb(mongoUri);\n  const doc = {\n    platform,\n    userId: String(userId),\n    chatId: chatId ? String(chatId) : \"\",\n    role,\n    text: String(text || \"\").slice(0, 4000),\n    ts: new Date(),\n  };\n\n  if (!db) return; // allow bot to run without DB\n  await db.collection(COL).insertOne(doc);\n}\n\nexport async function getRecentTurns({ mongoUri, platform, userId, chatId, limit = 14 }) {\n  const db = await getDb(mongoUri);\n  if (!db) return [];\n\n  const q = {\n    platform,\n    userId: String(userId),\n  };\n  if (chatId) q.chatId = String(chatId);\n\n  const rows = await db\n    .collection(COL)\n    .find(q)\n    .sort({ ts: -1 })\n    .limit(limit)\n    .toArray();\n\n  // return chronological\n  return rows.reverse().map((r) => ({ role: r.role, text: r.text }));\n}\n\nexport async function clearUserMemory({ mongoUri, platform, userId, chatId }) {\n  const db = await getDb(mongoUri);\n  if (!db) return;\n\n  const q = { platform, userId: String(userId) };\n  if (chatId) q.chatId = String(chatId);\n\n  await db.collection(COL).deleteMany(q);\n}"
                  }
                }
              },
              "services": {
                "type": "dir",
                "children": {
                  "alerts.js": {
                    "type": "file",
                    "content": "import { ObjectId } from \"mongodb\";\nimport { getDb } from \"../lib/db.js\";\nimport { safeErr } from \"../lib/log.js\";\n\nexport function normalizeDirection(d) {\n  const v = String(d || \"\").trim().toLowerCase();\n  if (v === \"above\" || v === \"up\" || v === \"over\") return \"above\";\n  if (v === \"below\" || v === \"down\" || v === \"under\") return \"below\";\n  return null;\n}\n\nexport function parseTargetPrice(s) {\n  const v = Number(String(s || \"\").replace(/,/g, \"\").trim());\n  if (!Number.isFinite(v) || v <= 0) return null;\n  return v;\n}\n\nexport async function createAlert({ mongoUri, log, telegramUserId, symbol, direction, target }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  const sym = String(symbol || \"\").trim().toUpperCase();\n  const dir = normalizeDirection(direction);\n  const tgt = typeof target === \"number\" ? target : parseTargetPrice(target);\n\n  if (!sym || !dir || !Number.isFinite(tgt)) return { ok: false, reason: \"bad_input\" };\n\n  const doc = {\n    telegramUserId: String(telegramUserId),\n    symbol: sym,\n    direction: dir,\n    target: tgt,\n    status: \"active\",\n    triggeredAt: null,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  };\n\n  try {\n    const r = await db.collection(\"alerts\").insertOne(doc);\n    return { ok: true, id: String(r.insertedId) };\n  } catch (e) {\n    log?.error(\"db alerts create failed\", { op: \"insertOne\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n\nexport async function listAlerts({ mongoUri, log, telegramUserId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\", alerts: [] };\n\n  try {\n    const rows = await db\n      .collection(\"alerts\")\n      .find({ telegramUserId: String(telegramUserId) })\n      .sort({ createdAt: -1 })\n      .limit(100)\n      .toArray();\n\n    return {\n      ok: true,\n      alerts: rows.map((a) => ({\n        id: String(a._id),\n        symbol: String(a.symbol || \"\").toUpperCase(),\n        direction: a.direction === \"below\" ? \"below\" : \"above\",\n        target: Number(a.target),\n        status: a.status === \"triggered\" ? \"triggered\" : \"active\",\n        createdAt: a.createdAt ? new Date(a.createdAt) : null,\n        triggeredAt: a.triggeredAt ? new Date(a.triggeredAt) : null,\n      })),\n    };\n  } catch (e) {\n    log?.error(\"db alerts list failed\", { op: \"find\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\", alerts: [] };\n  }\n}\n\nexport async function removeAlert({ mongoUri, log, telegramUserId, alertId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  try {\n    const _id = new ObjectId(String(alertId));\n    const r = await db.collection(\"alerts\").deleteOne({ _id, telegramUserId: String(telegramUserId) });\n    return { ok: true, removed: r.deletedCount || 0 };\n  } catch (e) {\n    log?.warn(\"db alerts remove failed\", { op: \"deleteOne\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"bad_id\" };\n  }\n}\n\nexport async function clearAlerts({ mongoUri, log, telegramUserId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  try {\n    const r = await db.collection(\"alerts\").deleteMany({ telegramUserId: String(telegramUserId) });\n    return { ok: true, removed: r.deletedCount || 0 };\n  } catch (e) {\n    log?.error(\"db alerts clear failed\", { op: \"deleteMany\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n\nexport async function loadActiveAlerts({ mongoUri, log }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\", alerts: [] };\n\n  try {\n    const rows = await db\n      .collection(\"alerts\")\n      .find({ status: \"active\" })\n      .sort({ createdAt: 1 })\n      .limit(5000)\n      .toArray();\n\n    return {\n      ok: true,\n      alerts: rows.map((a) => ({\n        id: String(a._id),\n        telegramUserId: String(a.telegramUserId),\n        symbol: String(a.symbol || \"\").toUpperCase(),\n        direction: a.direction === \"below\" ? \"below\" : \"above\",\n        target: Number(a.target),\n      })),\n    };\n  } catch (e) {\n    log?.error(\"db alerts loadActive failed\", { op: \"find\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\", alerts: [] };\n  }\n}\n\nexport async function markTriggered({ mongoUri, log, alertId, currentPrice }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  try {\n    const _id = new ObjectId(String(alertId));\n    await db.collection(\"alerts\").updateOne(\n      { _id, status: \"active\" },\n      {\n        $set: {\n          status: \"triggered\",\n          triggeredAt: new Date(),\n          updatedAt: new Date(),\n          lastKnownPrice: Number.isFinite(currentPrice) ? currentPrice : null,\n        },\n      }\n    );\n    return { ok: true };\n  } catch (e) {\n    log?.error(\"db alerts markTriggered failed\", { op: \"updateOne\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n"
                  },
                  "marketData.js": {
                    "type": "file",
                    "content": "import { safeErr } from \"../lib/log.js\";\n\nfunction sleep(ms) {\n  return new Promise((r) => setTimeout(r, ms));\n}\n\nfunction normalizeSymbol(symbol) {\n  return String(symbol || \"\").trim().toUpperCase();\n}\n\nconst DEFAULT_SYMBOL_MAP = {\n  BTC: { id: \"bitcoin\", name: \"Bitcoin\" },\n  ETH: { id: \"ethereum\", name: \"Ethereum\" },\n  SOL: { id: \"solana\", name: \"Solana\" },\n  BNB: { id: \"binancecoin\", name: \"BNB\" },\n  XRP: { id: \"ripple\", name: \"XRP\" },\n  ADA: { id: \"cardano\", name: \"Cardano\" },\n  DOGE: { id: \"dogecoin\", name: \"Dogecoin\" },\n  TRX: { id: \"tron\", name: \"TRON\" },\n  TON: { id: \"the-open-network\", name: \"Toncoin\" },\n  AVAX: { id: \"avalanche-2\", name: \"Avalanche\" },\n  DOT: { id: \"polkadot\", name: \"Polkadot\" },\n  LINK: { id: \"chainlink\", name: \"Chainlink\" },\n  MATIC: { id: \"matic-network\", name: \"Polygon\" },\n  POL: { id: \"matic-network\", name: \"Polygon\" },\n  SHIB: { id: \"shiba-inu\", name: \"Shiba Inu\" },\n  LTC: { id: \"litecoin\", name: \"Litecoin\" },\n  BCH: { id: \"bitcoin-cash\", name: \"Bitcoin Cash\" },\n  UNI: { id: \"uniswap\", name: \"Uniswap\" },\n  ATOM: { id: \"cosmos\", name: \"Cosmos\" },\n  NEAR: { id: \"near\", name: \"NEAR\" },\n};\n\nexport class MarketDataService {\n  constructor({ baseUrl, cacheTtlMs, log }) {\n    this.baseUrl = String(baseUrl || \"https://api.coingecko.com/api/v3\").replace(/\\/+$/, \"\");\n    this.cacheTtlMs = Number.isFinite(cacheTtlMs) && cacheTtlMs > 0 ? cacheTtlMs : 30_000;\n    this.log = log;\n\n    this.priceCache = new Map();\n    this.inflight = new Map();\n\n    this.symbolMap = new Map(Object.entries(DEFAULT_SYMBOL_MAP).map(([sym, v]) => [sym, v]));\n    this.symbolMapFetchedAt = 0;\n  }\n\n  async getQuoteBySymbol(symbol, { allowStale = true } = {}) {\n    const sym = normalizeSymbol(symbol);\n    if (!sym) return { ok: false, reason: \"missing_symbol\" };\n\n    const mapping = await this.resolveSymbol(sym);\n    if (!mapping) return { ok: false, reason: \"unknown_symbol\", symbol: sym };\n\n    return this.getQuoteByCoinId(mapping.id, { symbol: sym, name: mapping.name, allowStale });\n  }\n\n  async resolveSymbol(sym) {\n    const known = this.symbolMap.get(sym);\n    if (known) return known;\n\n    await this.refreshSymbolMapIfNeeded();\n    return this.symbolMap.get(sym) || null;\n  }\n\n  async refreshSymbolMapIfNeeded() {\n    const now = Date.now();\n    const maxAge = 6 * 60 * 60 * 1000;\n    if (this.symbolMapFetchedAt && now - this.symbolMapFetchedAt < maxAge) return;\n\n    const url = `${this.baseUrl}/coins/list?include_platform=false`;\n    this.log?.info(\"market symbol map fetch start\", { urlHost: safeHost(this.baseUrl) });\n\n    try {\n      const r = await fetch(url, { headers: { \"accept\": \"application/json\" }, signal: AbortSignal.timeout(10_000) });\n      if (!r.ok) throw new Error(`HTTP_${r.status}`);\n      const rows = await r.json();\n      if (!Array.isArray(rows)) throw new Error(\"BAD_RESPONSE\");\n\n      const next = new Map(this.symbolMap);\n      for (const row of rows) {\n        const s = String(row?.symbol || \"\").trim().toUpperCase();\n        const id = String(row?.id || \"\").trim();\n        const name = String(row?.name || \"\").trim();\n        if (!s || !id) continue;\n        if (!next.has(s)) next.set(s, { id, name: name || s });\n      }\n\n      this.symbolMap = next;\n      this.symbolMapFetchedAt = now;\n      this.log?.info(\"market symbol map fetch ok\", { symbols: this.symbolMap.size });\n    } catch (e) {\n      this.log?.warn(\"market symbol map fetch failed\", { err: safeErr(e) });\n      this.symbolMapFetchedAt = now;\n    }\n  }\n\n  async getQuoteByCoinId(coinId, { symbol, name, allowStale }) {\n    const key = `cg:${coinId}:usd`;\n    const now = Date.now();\n    const cached = this.priceCache.get(key);\n\n    if (cached && cached.expiresAt > now) {\n      return { ok: true, ...cached.value, source: \"cache\", stale: false };\n    }\n\n    if (this.inflight.has(key)) {\n      try {\n        const v = await this.inflight.get(key);\n        return v;\n      } catch {\n        // fall through\n      }\n    }\n\n    const p = this._fetchCoinGeckoQuote(coinId, { symbol, name, allowStale, cached });\n    this.inflight.set(key, p);\n    try {\n      return await p;\n    } finally {\n      this.inflight.delete(key);\n    }\n  }\n\n  async _fetchCoinGeckoQuote(coinId, { symbol, name, allowStale, cached }) {\n    const url = `${this.baseUrl}/simple/price?ids=${encodeURIComponent(String(coinId))}&vs_currencies=usd&include_24hr_change=true`;\n\n    this.log?.info(\"market quote fetch start\", { coinId, symbol, urlHost: safeHost(this.baseUrl) });\n\n    try {\n      const started = Date.now();\n      const r = await fetch(url, { headers: { \"accept\": \"application/json\" }, signal: AbortSignal.timeout(10_000) });\n      const ms = Date.now() - started;\n\n      if (!r.ok) throw new Error(`HTTP_${r.status}`);\n      const json = await r.json();\n\n      const row = json?.[coinId];\n      const price = Number(row?.usd);\n      const change = Number(row?.usd_24h_change);\n\n      if (!Number.isFinite(price)) throw new Error(\"BAD_PRICE\");\n\n      const value = {\n        coinId,\n        name: String(name || \"\") || null,\n        symbol: String(symbol || \"\") || null,\n        priceUsd: price,\n        change24hPct: Number.isFinite(change) ? change : null,\n        ts: new Date(),\n      };\n\n      this.priceCache.set(`cg:${coinId}:usd`, {\n        value,\n        expiresAt: Date.now() + this.cacheTtlMs,\n        fetchedAt: Date.now(),\n      });\n\n      this.log?.info(\"market quote fetch ok\", { coinId, symbol, ms });\n      return { ok: true, ...value, source: \"api\", stale: false };\n    } catch (e) {\n      const errMsg = safeErr(e);\n      this.log?.warn(\"market quote fetch failed\", { coinId, symbol, err: errMsg });\n\n      if (allowStale && cached?.value) {\n        const ageMs = Date.now() - (cached.fetchedAt || 0);\n        return { ok: true, ...cached.value, source: \"cache\", stale: true, staleAgeMs: ageMs };\n      }\n\n      return { ok: false, reason: \"api_down\", coinId, symbol };\n    }\n  }\n\n  async getQuotesForSymbols(symbols) {\n    const out = new Map();\n    const unique = [...new Set((symbols || []).map(normalizeSymbol).filter(Boolean))];\n\n    for (const sym of unique) {\n      const r = await this.getQuoteBySymbol(sym, { allowStale: true });\n      out.set(sym, r);\n      await sleep(0);\n    }\n    return out;\n  }\n}\n\nfunction safeHost(baseUrl) {\n  try {\n    const u = new URL(String(baseUrl));\n    return u.host;\n  } catch {\n    return \"\";\n  }\n}\n"
                  },
                  "users.js": {
                    "type": "file",
                    "content": "import { getDb } from \"../lib/db.js\";\nimport { safeErr } from \"../lib/log.js\";\n\nexport async function upsertUser({ mongoUri, log, telegramUserId, chatId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  try {\n    await db.collection(\"users\").updateOne(\n      { telegramUserId: String(telegramUserId) },\n      {\n        $setOnInsert: { createdAt: new Date() },\n        $set: {\n          telegramUserId: String(telegramUserId),\n          chatId: chatId ? String(chatId) : \"\",\n          updatedAt: new Date(),\n        },\n      },\n      { upsert: true }\n    );\n    return { ok: true };\n  } catch (e) {\n    log?.error(\"db users upsert failed\", { op: \"updateOne\", col: \"users\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n"
                  },
                  "watchlists.js": {
                    "type": "file",
                    "content": "import { getDb } from \"../lib/db.js\";\nimport { safeErr } from \"../lib/log.js\";\n\nexport async function getWatchlist({ mongoUri, log, telegramUserId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\", symbols: [] };\n\n  try {\n    const doc = await db.collection(\"watchlists\").findOne({ telegramUserId: String(telegramUserId) });\n    const symbols = Array.isArray(doc?.symbols) ? doc.symbols.map((s) => String(s).toUpperCase()) : [];\n    return { ok: true, symbols };\n  } catch (e) {\n    log?.error(\"db watchlists get failed\", { op: \"findOne\", col: \"watchlists\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\", symbols: [] };\n  }\n}\n\nexport async function hasInWatchlist({ mongoUri, log, telegramUserId, symbol }) {\n  const r = await getWatchlist({ mongoUri, log, telegramUserId });\n  if (!r.ok) return { ok: false, has: false };\n  const sym = String(symbol || \"\").trim().toUpperCase();\n  return { ok: true, has: r.symbols.includes(sym) };\n}\n\nexport async function addToWatchlist({ mongoUri, log, telegramUserId, symbol }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  const sym = String(symbol || \"\").trim().toUpperCase();\n  if (!sym) return { ok: false, reason: \"bad_symbol\" };\n\n  try {\n    await db.collection(\"watchlists\").updateOne(\n      { telegramUserId: String(telegramUserId) },\n      {\n        $setOnInsert: { createdAt: new Date() },\n        $set: { updatedAt: new Date() },\n        $addToSet: { symbols: sym },\n      },\n      { upsert: true }\n    );\n    return { ok: true };\n  } catch (e) {\n    log?.error(\"db watchlists add failed\", { op: \"updateOne\", col: \"watchlists\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n\nexport async function removeFromWatchlist({ mongoUri, log, telegramUserId, symbol }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  const sym = String(symbol || \"\").trim().toUpperCase();\n  if (!sym) return { ok: false, reason: \"bad_symbol\" };\n\n  try {\n    await db.collection(\"watchlists\").updateOne(\n      { telegramUserId: String(telegramUserId) },\n      {\n        $set: { updatedAt: new Date() },\n        $pull: { symbols: sym },\n      },\n      { upsert: true }\n    );\n    return { ok: true };\n  } catch (e) {\n    log?.error(\"db watchlists remove failed\", { op: \"updateOne\", col: \"watchlists\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n\nexport async function clearWatchlist({ mongoUri, log, telegramUserId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  try {\n    await db.collection(\"watchlists\").updateOne(\n      { telegramUserId: String(telegramUserId) },\n      {\n        $setOnInsert: { },\n        $set: { symbols: [], updatedAt: new Date() },\n      },\n      { upsert: true }\n    );\n    return { ok: true };\n  } catch (e) {\n    log?.error(\"db watchlists clear failed\", { op: \"updateOne\", col: \"watchlists\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n"
                  }
                }
              }
            }
          }
        },
        "commands": [
          {
            "command": "/alert",
            "description": "Adds or removes a price alert.",
            "usage": "/alert add BTC above 70000 | /alert add ETH below 2000 | /alert remove <alertId>",
            "examples": [
              "User: /alert add BTC above 70000 → Bot: Alert created: 3f9a12c1",
              "User: /alert remove 65d4b2f3c9a0f0c2f91d8a11 → Bot: Alert removed."
            ],
            "example": "User: /alert add BTC above 70000 → Bot: Alert created: 3f9a12c1",
            "notes": "Alerts trigger once and are kept as history by marking status=triggered."
          },
          {
            "command": "/alerts",
            "description": "Lists your alerts and provides inline remove buttons.",
            "usage": "/alerts",
            "examples": [
              "User: /alerts → Bot: alert list with short ids + remove buttons"
            ],
            "example": "User: /alerts → Bot: alert list with short ids + remove buttons",
            "notes": "Requires MONGODB_URI."
          },
          {
            "command": "/help",
            "description": "Shows all commands with examples and explains polling-based alert behavior.",
            "usage": "/help",
            "examples": [
              "User: /help → Bot: command list + examples"
            ],
            "example": "User: /help → Bot: command list + examples",
            "notes": "Matches the implemented public commands."
          },
          {
            "command": "/price",
            "description": "Fetches current USD price and 24h percent change for a symbol and shows inline actions.",
            "usage": "/price BTC",
            "examples": [
              "User: /price BTC → Bot: price + change + buttons"
            ],
            "example": "User: /price BTC → Bot: price + change + buttons",
            "notes": "If the market API is down, the bot replies with a consistent fallback message (or cached data if available)."
          },
          {
            "command": "/reset",
            "description": "Clears your watchlist and alerts.",
            "usage": "/reset",
            "examples": [
              "User: /reset → Bot: Done. Your watchlist and alerts were cleared."
            ],
            "example": "User: /reset → Bot: Done. Your watchlist and alerts were cleared.",
            "notes": "Requires MONGODB_URI."
          },
          {
            "command": "/start",
            "description": "Welcome message plus inline menu for Price Lookup, Watchlist, Alerts, and Help.",
            "usage": "/start",
            "examples": [
              "User: /start → Bot: Welcome message + buttons"
            ],
            "example": "User: /start → Bot: Welcome message + buttons",
            "notes": "If MONGODB_URI is not set, the bot will mention that watchlists and alerts are disabled."
          },
          {
            "command": "/watchlist",
            "description": "Lists or updates your watchlist.",
            "usage": "/watchlist | /watchlist add BTC | /watchlist remove BTC",
            "examples": [
              "User: /watchlist → Bot: list of symbols + remove buttons",
              "User: /watchlist add ETH → Bot: confirmed + updated list"
            ],
            "example": "User: /watchlist → Bot: list of symbols + remove buttons",
            "notes": "Requires MONGODB_URI."
          }
        ],
        "envVarDocs": [
          {
            "key": "TELEGRAM_BOT_TOKEN",
            "title": "Telegram Bot Token",
            "description": "Required token for the Telegram bot API.",
            "usage": "Used on boot to create the grammY Bot instance.",
            "howToGet": "Create a bot with BotFather on Telegram and copy the token.",
            "example": "123456789:ABCDEF_your_token_here",
            "isSecret": true,
            "required": true
          },
          {
            "key": "MONGODB_URI",
            "title": "MongoDB Connection String",
            "description": "MongoDB connection string used to persist users, watchlists, and alerts.",
            "usage": "If missing, the bot still runs but watchlists and alerts are disabled.",
            "howToGet": "Use MongoDB Atlas or a managed MongoDB provider and copy the connection string.",
            "example": "mongodb+srv://user:pass@cluster.example.mongodb.net/mydb",
            "isSecret": true,
            "required": false
          },
          {
            "key": "COIN_API_BASE_URL",
            "title": "Market Data API Base URL",
            "description": "Base URL for the market data provider (default: CoinGecko v3).",
            "usage": "Used by MarketDataService for price and symbol list requests.",
            "howToGet": "Optional. Leave default unless you are using a proxy/mirror.",
            "example": "https://api.coingecko.com/api/v3",
            "isSecret": false,
            "required": false
          },
          {
            "key": "CACHE_TTL_MS",
            "title": "Price Cache TTL (ms)",
            "description": "How long price results are cached per symbol to reduce API calls.",
            "usage": "Used by MarketDataService for in-memory caching.",
            "howToGet": "Optional tuning parameter.",
            "example": "30000",
            "isSecret": false,
            "required": false
          },
          {
            "key": "POLL_INTERVAL_MS",
            "title": "Alert Polling Interval (ms)",
            "description": "How often the bot checks active alerts and sends notifications when targets are hit.",
            "usage": "Used by the in-process alert poller loop.",
            "howToGet": "Optional tuning parameter.",
            "example": "45000",
            "isSecret": false,
            "required": false
          },
          {
            "key": "LOG_LEVEL",
            "title": "Log Level",
            "description": "Controls logging verbosity.",
            "usage": "Used by src/lib/log.js to filter logs.",
            "howToGet": "Optional tuning parameter.",
            "example": "info",
            "isSecret": false,
            "required": false
          }
        ],
        "commandDocs": [
          {
            "command": "/start",
            "description": "Welcome message plus inline menu for Price Lookup, Watchlist, Alerts, and Help.",
            "usage": "/start",
            "examples": [
              "User: /start → Bot: Welcome message + buttons"
            ],
            "notes": "If MONGODB_URI is not set, the bot will mention that watchlists and alerts are disabled."
          },
          {
            "command": "/help",
            "description": "Shows all commands with examples and explains polling-based alert behavior.",
            "usage": "/help",
            "examples": [
              "User: /help → Bot: command list + examples"
            ],
            "notes": "Matches the implemented public commands."
          },
          {
            "command": "/price",
            "description": "Fetches current USD price and 24h percent change for a symbol and shows inline actions.",
            "usage": "/price BTC",
            "examples": [
              "User: /price BTC → Bot: price + change + buttons"
            ],
            "notes": "If the market API is down, the bot replies with a consistent fallback message (or cached data if available)."
          },
          {
            "command": "/watchlist",
            "description": "Lists or updates your watchlist.",
            "usage": "/watchlist | /watchlist add BTC | /watchlist remove BTC",
            "examples": [
              "User: /watchlist → Bot: list of symbols + remove buttons",
              "User: /watchlist add ETH → Bot: confirmed + updated list"
            ],
            "notes": "Requires MONGODB_URI."
          },
          {
            "command": "/alerts",
            "description": "Lists your alerts and provides inline remove buttons.",
            "usage": "/alerts",
            "examples": [
              "User: /alerts → Bot: alert list with short ids + remove buttons"
            ],
            "notes": "Requires MONGODB_URI."
          },
          {
            "command": "/alert",
            "description": "Adds or removes a price alert.",
            "usage": "/alert add BTC above 70000 | /alert add ETH below 2000 | /alert remove <alertId>",
            "examples": [
              "User: /alert add BTC above 70000 → Bot: Alert created: 3f9a12c1",
              "User: /alert remove 65d4b2f3c9a0f0c2f91d8a11 → Bot: Alert removed."
            ],
            "notes": "Alerts trigger once and are kept as history by marking status=triggered."
          },
          {
            "command": "/reset",
            "description": "Clears your watchlist and alerts.",
            "usage": "/reset",
            "examples": [
              "User: /reset → Bot: Done. Your watchlist and alerts were cleared."
            ],
            "notes": "Requires MONGODB_URI."
          }
        ],
        "aiMessages": [
          {
            "role": "user",
            "content": "Build a Telegram crypto price + alerts bot:\n\n- Watchlist: add/remove coins and list watchlist.\n- Price lookup: /price <symbol> (returns price + 24h change).\n- Alerts: set above/below alerts per coin; list and remove alerts.\n- Notifications: alert users when targets are hit.\n- Reliability: caching, graceful errors, and “API down” fallback message.\n- UX: quick inline buttons for common actions (Add alert, Remove, Watchlist)."
          },
          {
            "role": "assistant",
            "content": "Created a new grammY Telegram bot project for crypto price lookup, watchlists, and polling-based alerts with inline-button UX. Added MongoDB persistence (users/watchlists/alerts), a CoinGecko market data service with caching and stale fallback, an in-process alert poller that groups checks by symbol and triggers notifications once, plus production-safe logging and DOCS/.env.sample.\n\nFiles touched (28): .env.sample, DOCS.md, README.md, package.json, project.json, src/bot.js…\nValidation: ✅ project passes syntax/basic checks after this edit."
          }
        ],
        "createdBy": "",
        "source": "",
        "description": "",
        "planMarkdown": "Bot: Telegram Crypto Price + Alerts Bot (grammY, Node.js ESM) — Production-Ready System Plan\n\nSummary:\nA single-process Telegram bot that lets users look up crypto prices, manage a personal watchlist, and configure above/below price alerts per coin. The bot periodically checks prices from an external market-data API and sends notifications when alert conditions are met.\n\nThe plan emphasizes reliability (caching, rate limiting, graceful degradation when APIs are down), good UX (inline buttons for common actions, clear formatting, and guided flows), and maintainability (clean separation of concerns, MongoDB persistence, idempotent alert triggering, and observable operations).\n\nProduct goals:\nPrimary user goals\n\n1) Fast price lookup: Users can request /price BTC and instantly receive the current price and 24h change.\n2) Personal watchlist: Users can maintain a list of coins they care about and retrieve it quickly.\n3) Price alerts: Users can set alerts like BTC above 70000 or ETH below 3000 and be notified when thresholds are crossed.\n4) Low-friction UX: Inline buttons reduce typing; bot responses include quick next actions (Add alert, Remove, Watchlist).\n\nProduct principles\n\n1) Correctness over completeness: Prefer a smaller set of reliably supported symbols over trying to resolve every ambiguous ticker.\n2) Predictable alerts: Alerts should trigger once per condition hit and avoid spam during volatility.\n3) Transparent reliability: When upstream APIs fail, return a clear fallback message and keep bot responsive.\n4) Minimal user configuration: Default currency (e.g., USD) and sane defaults for alert behavior; allow customization later.\n\nScope boundaries (v1)\n\n1) Not a trading bot; no orders, wallets, or sensitive user keys.\n2) No complex technical indicators; only spot price and 24h change.\n3) Alerts are based on spot price threshold crossing, not candles or time windows.\n\nHigh-level architecture:\nHigh-level architecture (single Node.js process)\n\n1) Telegram interaction layer (grammY)\n   1) Command handlers: /start, /price, /watchlist, /alerts, etc.\n   2) Callback query handlers for inline buttons.\n   3) Input parsing and validation (symbols, prices).\n\n2) Domain services\n   1) MarketDataService: fetches prices and 24h change, normalizes data, handles symbol mapping.\n   2) WatchlistService: add/remove/list watchlist entries.\n   3) AlertsService: create/list/delete alerts; evaluate alerts against prices; manage alert state to prevent duplicate notifications.\n   4) NotificationService: sends messages; handles failures (blocked bot, chat not found) and updates user status.\n\n3) Persistence (MongoDB)\n   1) Users, watchlists, alerts, symbol registry (optional), and operational state needed for alert triggering.\n\n4) Caching and rate control (in-process)\n   1) Short-lived cache for price lookups to reduce API calls (e.g., 10–30 seconds per symbol).\n   2) In-flight request de-duplication per symbol (avoid concurrent fetch storms).\n   3) Global throttling for upstream API calls.\n\n5) Scheduler (in-process loop)\n   1) Periodic alert evaluation job (e.g., every 15–30 seconds; configurable).\n   2) Batching strategy: compute unique symbols needed by active alerts, fetch prices in batches when supported by the provider, then evaluate all alerts.\n\nOperational lifecycle\n\n1) Bot starts, connects to MongoDB, initializes grammY, registers handlers.\n2) Scheduler starts after successful initialization.\n3) Health and readiness checks are exposed internally (for the host environment) and logged.\n\nFailure isolation\n\n1) Upstream API failure must not crash the bot. Errors are caught and turned into:\n   1) User-facing fallback response for /price.\n   2) Skipped alert cycle with backoff for scheduler.\n2) Telegram send failures are handled per message; persistent failures mark user as unreachable to reduce retries.\n\nSymbol resolution strategy\n\n1) Maintain a canonical internal coinId (string) separate from user-entered symbol.\n2) Use a deterministic mapping table for popular symbols (BTC, ETH, SOL, etc.).\n3) When ambiguous (e.g., multiple assets share a symbol), the bot responds with a disambiguation prompt via inline buttons. Store the resolved mapping per user preference to reduce future ambiguity.\n\nData model:\nMongoDB collections (suggested)\n\n1) users\n   1) id: ObjectId\n   2) telegramUserId: number (unique)\n   3) chatId: number (for direct messages; for groups store per chat usage if supported)\n   4) locale: string (optional)\n   5) defaultFiat: string (e.g., USD)\n   6) createdAt, updatedAt\n   7) status:\n      1) active | blocked | unreachable\n      2) lastSendErrorAt, lastSendErrorReason\n\n2) watchlists\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) items: array of\n      1) coinId: string\n      2) symbol: string (display)\n      3) addedAt: date\n   4) updatedAt\n   Notes:\n   1) Alternatively store as separate documents per item for easier indexing; for v1 array is fine if sizes remain small.\n\n3) alerts\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) coinId: string (indexed)\n   4) symbol: string (display)\n   5) direction: above | below\n   6) targetPrice: number\n   7) fiat: string (e.g., USD)\n   8) status: active | triggered | paused\n   9) createdAt, updatedAt\n   10) triggeredAt: date (nullable)\n   11) lastEvaluatedAt: date (optional)\n   12) lastKnownPrice: number (optional)\n   13) triggerPolicy:\n       1) once (default) or repeat\n       2) if repeat: cooldownSeconds\n   Rationale:\n   1) Storing lastKnownPrice enables crossing detection (trigger only when crossing occurs, not merely staying above).\n\n4) coinregistry (optional but recommended)\n   1) coinId: string (unique)\n   2) primarySymbol: string\n   3) name: string\n   4) aliases: array of strings\n   5) providerIdentifiers: object (per market data provider)\n   6) updatedAt\n   Notes:\n   1) Can be curated for top coins and extended later; not mandatory for v1 if provider supports direct symbol query.\n\nIndexes\n\n1) users: unique index on telegramUserId\n2) alerts: compound index on status + coinId (for fast retrieval of active alerts grouped by symbol)\n3) alerts: index on telegramUserId (for list operations)\n4) watchlists: index on telegramUserId\n\nIn-memory structures (non-persistent)\n\n1) priceCache: Map keyed by coinId+fiat with value {price, change24h, fetchedAt, expiresAt}\n2) inflightFetches: Map keyed by coinId+fiat to Promise-like tracking to deduplicate\n3) schedulerState: lastRunAt, consecutiveFailures, backoffUntil\n\nKey flows:\n1) /start onboarding\n\n1) Create or update user record (telegramUserId, chatId).\n2) Send a welcome message with:\n   1) How to use /price\n   2) How to add alerts\n   3) Inline buttons: Price, Watchlist, Alerts\n\n2) Price lookup: /price <symbol>\n\n1) Parse input symbol; normalize (trim, uppercase).\n2) Resolve to coinId:\n   1) If exact match in coin registry, proceed.\n   2) If ambiguous, return a list of options via inline buttons.\n   3) If unknown, return a helpful error and suggest examples.\n3) Fetch market data:\n   1) Check cache (fresh within TTL). If present, use it.\n   2) Else call MarketDataService with retry policy (limited) and timeout.\n4) Reply with formatted result:\n   1) Price in defaultFiat\n   2) 24h change (percentage)\n   3) Last updated timestamp\n   4) Inline buttons: Add alert (above/below), Add to watchlist, View alerts for this coin\n5) If API fails:\n   1) Reply with fallback message: market data temporarily unavailable; suggest trying again.\n   2) Optionally show the last cached value if it exists but is stale, clearly marked as stale.\n\n3) Watchlist management\n\nA) Add: /watchlistadd <symbol> (and inline button Add to watchlist)\n1) Resolve symbol to coinId (same as /price).\n2) Upsert watchlist item; avoid duplicates.\n3) Confirm and show watchlist summary with inline actions.\n\nB) Remove: /watchlistremove <symbol> (and inline button Remove)\n1) Resolve symbol.\n2) Remove if present.\n3) Confirm outcome (removed or not found).\n\nC) List: /watchlist\n1) Load watchlist items.\n2) Optionally fetch current prices for items:\n   1) Batch fetch unique coinIds with caching.\n   2) Show a compact list with price and 24h change.\n3) Provide inline buttons per item: Price, Add alert, Remove.\n\n4) Alerts management\n\nA) Create: /alert <symbol> <above|below> <price>\n1) Parse and validate numeric target price.\n2) Resolve symbol to coinId.\n3) Create alert with status active and default triggerPolicy once.\n4) Reply with confirmation and inline buttons:\n   1) List alerts\n   2) Remove this alert\n   3) View price\n\nB) Guided creation via inline buttons\n1) User taps Add alert from a price message.\n2) Bot prompts:\n   1) Choose direction (above/below) via buttons.\n   2) Enter target price (free text).\n3) Validate and create alert.\n\nC) List: /alerts\n1) Load alerts for user.\n2) Group by coin and show status (active/triggered).\n3) Inline buttons for each alert: Remove, Pause/Resume (optional), View price.\n\nD) Remove: /alertremove <id> or via inline button\n1) Validate ownership (telegramUserId matches).\n2) Delete or mark as deleted.\n3) Confirm.\n\n5) Notification cycle (scheduler)\n\n1) Every interval, load active alerts (status=active).\n2) Determine unique coinIds needed; fetch prices (batch when possible).\n3) For each alert evaluate condition:\n   1) Above: currentPrice >= targetPrice\n   2) Below: currentPrice <= targetPrice\n4) Anti-spam and correctness:\n   1) Default behavior triggers once then marks triggered.\n   2) Optional crossing logic: if lastKnownPrice exists, only trigger when crossing the threshold from the other side.\n   3) Record triggeredAt and status update.\n5) Send notification:\n   1) Message includes coin, current price, target, and quick actions (Remove, Add another alert, View price).\n   2) Handle send errors; if blocked/unreachable, set user status accordingly.\n6) Persist updates (alert status, lastKnownPrice).\n\n6) Resilience and fallback behaviors\n\n1) If market data API is down during /price:\n   1) Respond quickly with a user-friendly error.\n   2) Optionally include stale cached value if available.\n2) If API is down during scheduler:\n   1) Skip evaluation cycle.\n   2) Increase backoff and log the incident.\n3) If MongoDB is temporarily unavailable:\n   1) Commands that require persistence return a degraded-mode message.\n   2) Price lookup may still work using in-memory cache only.\n4) Telegram rate limits:\n   1) NotificationService batches or throttles sends.\n   2) Avoid sending multiple alerts in one second to the same chat; combine messages when many alerts trigger simultaneously.\n\nTech stack:\nRuntime and framework\n\n1) Node.js (ESM) single service/process.\n2) grammY for Telegram bot API integration.\n3) Environment configuration via process environment variables, including TELEGRAMBOTTOKEN.\n\nPersistence\n\n1) MongoDB for durable storage of users, watchlists, and alerts.\n2) In-memory maps for short-lived caching and in-flight request deduplication.\n\nExternal integration\n\n1) One primary market data API provider (HTTP-based) that supports:\n   1) Spot price per coin in a fiat currency\n   2) 24h change\n   3) Optional batch queries\n2) Optional secondary provider as fallback if allowed; otherwise provide a clear API-down message.\n\nStorage\n\n1) No file storage is required for core features.\n2) If later adding charts or snapshots, store generated images in object storage or simple filesystem storage.\n\nDeployment\n\n1) Run as a Node.js server in the cloud.\n2) Use long polling or webhook mode depending on hosting capabilities; both remain within a single process.\n\nOperational tooling (within the same service)\n\n1) Structured logging (request/command context, correlation ids for updates).\n2) Basic internal metrics counters (in-memory) for:\n   1) /price requests\n   2) API successes/failures\n   3) alerts evaluated and triggered\n   4) Telegram send failures\n3) Health endpoints or health logging for readiness/liveness (implementation depends on hosting).\n\nNon-functional requirements:\nReliability\n\n1) Timeouts on all upstream HTTP calls; fail fast.\n2) Retries with jitter for transient failures (bounded, small count).\n3) Cache responses briefly to reduce load and improve latency.\n4) Scheduler backoff on repeated upstream failures.\n\nCorrectness and alert semantics\n\n1) Alerts are idempotent: once triggered, they are marked triggered to prevent repeats.\n2) Optional crossing detection reduces false triggers when an alert is created while already beyond target.\n3) All comparisons use consistent numeric parsing and rounding strategy; display rounding is separate from evaluation precision.\n\nPerformance\n\n1) Batch price fetching for alert evaluation.\n2) Avoid N+1 database calls by preloading active alerts and grouping them.\n3) Keep watchlists small by design; if large lists are allowed later, switch to per-item documents.\n\nSecurity and abuse prevention\n\n1) Input validation for symbols and target prices.\n2) Basic per-user rate limiting in memory to prevent spam (commands per minute).\n3) Do not log sensitive user content beyond what is required for debugging.\n4) Handle group chats carefully (optional in v1). If enabled, store alerts per chatId and ensure admin-only management if desired.\n\nObservability and operations\n\n1) Log all failures with actionable context (provider status, HTTP status, latency).\n2) Track alert trigger outcomes and Telegram send errors.\n3) Provide an admin-only command set for basic diagnostics (counts, last API error, scheduler status).\n\nUX and accessibility\n\n1) Consistent message format with compact numbers and clear timestamps.\n2) Inline buttons for common next steps:\n   1) Add alert above/below\n   2) Add/remove watchlist\n   3) List alerts\n3) Clear error messages with examples.\n\nData retention\n\n1) Keep triggered alerts for a limited time for user visibility, then optionally auto-archive/delete.\n2) Allow users to delete alerts and watchlist items at any time.\n\nTesting strategy (system-level plan)\n\n1) Unit test domain services (symbol resolution, alert evaluation, caching behavior).\n2) Integration test MongoDB operations for alerts and watchlists.\n3) End-to-end test key Telegram flows with simulated updates.\n4) Load test scheduler logic with many alerts to validate batching and rate limiting.\n\nBot commands:\n• /start — Initialize the bot, save your user profile, and show quick help with buttons. (usage: /start) [Onboarding]\n• /help — Show usage instructions and examples for prices, watchlists, and alerts. (usage: /help) [Onboarding]\n• /price — Get current price and 24h change for a symbol, with quick actions to add alerts or watchlist. (usage: /price <symbol>) [Market Data]\n• /watchlist — List your watchlist, optionally including current prices and 24h change, with per-coin actions. (usage: /watchlist) [Watchlist]\n• /watchlistadd — Add a coin to your watchlist. (usage: /watchlistadd <symbol>) [Watchlist]\n• /watchlistremove — Remove a coin from your watchlist. (usage: /watchlistremove <symbol>) [Watchlist]\n• /alerts — List all your alerts with status and quick buttons to remove or view price. (usage: /alerts) [Alerts]\n• /alert — Create a price threshold alert for a coin (above or below). (usage: /alert <symbol> <above|below> <targetPrice>) [Alerts]\n• /alertremove — Remove an alert by its id (or use inline buttons from /alerts). (usage: /alertremove <alertId>) [Alerts]\n• /status — Show basic bot status, including whether market data is currently available (admin-only). (usage: /status) [Admin]\n",
        "planSections": {
          "productGoals": "Primary user goals\n\n1) Fast price lookup: Users can request /price BTC and instantly receive the current price and 24h change.\n2) Personal watchlist: Users can maintain a list of coins they care about and retrieve it quickly.\n3) Price alerts: Users can set alerts like BTC above 70000 or ETH below 3000 and be notified when thresholds are crossed.\n4) Low-friction UX: Inline buttons reduce typing; bot responses include quick next actions (Add alert, Remove, Watchlist).\n\nProduct principles\n\n1) Correctness over completeness: Prefer a smaller set of reliably supported symbols over trying to resolve every ambiguous ticker.\n2) Predictable alerts: Alerts should trigger once per condition hit and avoid spam during volatility.\n3) Transparent reliability: When upstream APIs fail, return a clear fallback message and keep bot responsive.\n4) Minimal user configuration: Default currency (e.g., USD) and sane defaults for alert behavior; allow customization later.\n\nScope boundaries (v1)\n\n1) Not a trading bot; no orders, wallets, or sensitive user keys.\n2) No complex technical indicators; only spot price and 24h change.\n3) Alerts are based on spot price threshold crossing, not candles or time windows.",
          "highLevelArchitecture": "High-level architecture (single Node.js process)\n\n1) Telegram interaction layer (grammY)\n   1) Command handlers: /start, /price, /watchlist, /alerts, etc.\n   2) Callback query handlers for inline buttons.\n   3) Input parsing and validation (symbols, prices).\n\n2) Domain services\n   1) MarketDataService: fetches prices and 24h change, normalizes data, handles symbol mapping.\n   2) WatchlistService: add/remove/list watchlist entries.\n   3) AlertsService: create/list/delete alerts; evaluate alerts against prices; manage alert state to prevent duplicate notifications.\n   4) NotificationService: sends messages; handles failures (blocked bot, chat not found) and updates user status.\n\n3) Persistence (MongoDB)\n   1) Users, watchlists, alerts, symbol registry (optional), and operational state needed for alert triggering.\n\n4) Caching and rate control (in-process)\n   1) Short-lived cache for price lookups to reduce API calls (e.g., 10–30 seconds per symbol).\n   2) In-flight request de-duplication per symbol (avoid concurrent fetch storms).\n   3) Global throttling for upstream API calls.\n\n5) Scheduler (in-process loop)\n   1) Periodic alert evaluation job (e.g., every 15–30 seconds; configurable).\n   2) Batching strategy: compute unique symbols needed by active alerts, fetch prices in batches when supported by the provider, then evaluate all alerts.\n\nOperational lifecycle\n\n1) Bot starts, connects to MongoDB, initializes grammY, registers handlers.\n2) Scheduler starts after successful initialization.\n3) Health and readiness checks are exposed internally (for the host environment) and logged.\n\nFailure isolation\n\n1) Upstream API failure must not crash the bot. Errors are caught and turned into:\n   1) User-facing fallback response for /price.\n   2) Skipped alert cycle with backoff for scheduler.\n2) Telegram send failures are handled per message; persistent failures mark user as unreachable to reduce retries.\n\nSymbol resolution strategy\n\n1) Maintain a canonical internal coinId (string) separate from user-entered symbol.\n2) Use a deterministic mapping table for popular symbols (BTC, ETH, SOL, etc.).\n3) When ambiguous (e.g., multiple assets share a symbol), the bot responds with a disambiguation prompt via inline buttons. Store the resolved mapping per user preference to reduce future ambiguity.",
          "dataModel": "MongoDB collections (suggested)\n\n1) users\n   1) id: ObjectId\n   2) telegramUserId: number (unique)\n   3) chatId: number (for direct messages; for groups store per chat usage if supported)\n   4) locale: string (optional)\n   5) defaultFiat: string (e.g., USD)\n   6) createdAt, updatedAt\n   7) status:\n      1) active | blocked | unreachable\n      2) lastSendErrorAt, lastSendErrorReason\n\n2) watchlists\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) items: array of\n      1) coinId: string\n      2) symbol: string (display)\n      3) addedAt: date\n   4) updatedAt\n   Notes:\n   1) Alternatively store as separate documents per item for easier indexing; for v1 array is fine if sizes remain small.\n\n3) alerts\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) coinId: string (indexed)\n   4) symbol: string (display)\n   5) direction: above | below\n   6) targetPrice: number\n   7) fiat: string (e.g., USD)\n   8) status: active | triggered | paused\n   9) createdAt, updatedAt\n   10) triggeredAt: date (nullable)\n   11) lastEvaluatedAt: date (optional)\n   12) lastKnownPrice: number (optional)\n   13) triggerPolicy:\n       1) once (default) or repeat\n       2) if repeat: cooldownSeconds\n   Rationale:\n   1) Storing lastKnownPrice enables crossing detection (trigger only when crossing occurs, not merely staying above).\n\n4) coinregistry (optional but recommended)\n   1) coinId: string (unique)\n   2) primarySymbol: string\n   3) name: string\n   4) aliases: array of strings\n   5) providerIdentifiers: object (per market data provider)\n   6) updatedAt\n   Notes:\n   1) Can be curated for top coins and extended later; not mandatory for v1 if provider supports direct symbol query.\n\nIndexes\n\n1) users: unique index on telegramUserId\n2) alerts: compound index on status + coinId (for fast retrieval of active alerts grouped by symbol)\n3) alerts: index on telegramUserId (for list operations)\n4) watchlists: index on telegramUserId\n\nIn-memory structures (non-persistent)\n\n1) priceCache: Map keyed by coinId+fiat with value {price, change24h, fetchedAt, expiresAt}\n2) inflightFetches: Map keyed by coinId+fiat to Promise-like tracking to deduplicate\n3) schedulerState: lastRunAt, consecutiveFailures, backoffUntil",
          "keyFlows": "1) /start onboarding\n\n1) Create or update user record (telegramUserId, chatId).\n2) Send a welcome message with:\n   1) How to use /price\n   2) How to add alerts\n   3) Inline buttons: Price, Watchlist, Alerts\n\n2) Price lookup: /price <symbol>\n\n1) Parse input symbol; normalize (trim, uppercase).\n2) Resolve to coinId:\n   1) If exact match in coin registry, proceed.\n   2) If ambiguous, return a list of options via inline buttons.\n   3) If unknown, return a helpful error and suggest examples.\n3) Fetch market data:\n   1) Check cache (fresh within TTL). If present, use it.\n   2) Else call MarketDataService with retry policy (limited) and timeout.\n4) Reply with formatted result:\n   1) Price in defaultFiat\n   2) 24h change (percentage)\n   3) Last updated timestamp\n   4) Inline buttons: Add alert (above/below), Add to watchlist, View alerts for this coin\n5) If API fails:\n   1) Reply with fallback message: market data temporarily unavailable; suggest trying again.\n   2) Optionally show the last cached value if it exists but is stale, clearly marked as stale.\n\n3) Watchlist management\n\nA) Add: /watchlistadd <symbol> (and inline button Add to watchlist)\n1) Resolve symbol to coinId (same as /price).\n2) Upsert watchlist item; avoid duplicates.\n3) Confirm and show watchlist summary with inline actions.\n\nB) Remove: /watchlistremove <symbol> (and inline button Remove)\n1) Resolve symbol.\n2) Remove if present.\n3) Confirm outcome (removed or not found).\n\nC) List: /watchlist\n1) Load watchlist items.\n2) Optionally fetch current prices for items:\n   1) Batch fetch unique coinIds with caching.\n   2) Show a compact list with price and 24h change.\n3) Provide inline buttons per item: Price, Add alert, Remove.\n\n4) Alerts management\n\nA) Create: /alert <symbol> <above|below> <price>\n1) Parse and validate numeric target price.\n2) Resolve symbol to coinId.\n3) Create alert with status active and default triggerPolicy once.\n4) Reply with confirmation and inline buttons:\n   1) List alerts\n   2) Remove this alert\n   3) View price\n\nB) Guided creation via inline buttons\n1) User taps Add alert from a price message.\n2) Bot prompts:\n   1) Choose direction (above/below) via buttons.\n   2) Enter target price (free text).\n3) Validate and create alert.\n\nC) List: /alerts\n1) Load alerts for user.\n2) Group by coin and show status (active/triggered).\n3) Inline buttons for each alert: Remove, Pause/Resume (optional), View price.\n\nD) Remove: /alertremove <id> or via inline button\n1) Validate ownership (telegramUserId matches).\n2) Delete or mark as deleted.\n3) Confirm.\n\n5) Notification cycle (scheduler)\n\n1) Every interval, load active alerts (status=active).\n2) Determine unique coinIds needed; fetch prices (batch when possible).\n3) For each alert evaluate condition:\n   1) Above: currentPrice >= targetPrice\n   2) Below: currentPrice <= targetPrice\n4) Anti-spam and correctness:\n   1) Default behavior triggers once then marks triggered.\n   2) Optional crossing logic: if lastKnownPrice exists, only trigger when crossing the threshold from the other side.\n   3) Record triggeredAt and status update.\n5) Send notification:\n   1) Message includes coin, current price, target, and quick actions (Remove, Add another alert, View price).\n   2) Handle send errors; if blocked/unreachable, set user status accordingly.\n6) Persist updates (alert status, lastKnownPrice).\n\n6) Resilience and fallback behaviors\n\n1) If market data API is down during /price:\n   1) Respond quickly with a user-friendly error.\n   2) Optionally include stale cached value if available.\n2) If API is down during scheduler:\n   1) Skip evaluation cycle.\n   2) Increase backoff and log the incident.\n3) If MongoDB is temporarily unavailable:\n   1) Commands that require persistence return a degraded-mode message.\n   2) Price lookup may still work using in-memory cache only.\n4) Telegram rate limits:\n   1) NotificationService batches or throttles sends.\n   2) Avoid sending multiple alerts in one second to the same chat; combine messages when many alerts trigger simultaneously.",
          "techStack": "Runtime and framework\n\n1) Node.js (ESM) single service/process.\n2) grammY for Telegram bot API integration.\n3) Environment configuration via process environment variables, including TELEGRAMBOTTOKEN.\n\nPersistence\n\n1) MongoDB for durable storage of users, watchlists, and alerts.\n2) In-memory maps for short-lived caching and in-flight request deduplication.\n\nExternal integration\n\n1) One primary market data API provider (HTTP-based) that supports:\n   1) Spot price per coin in a fiat currency\n   2) 24h change\n   3) Optional batch queries\n2) Optional secondary provider as fallback if allowed; otherwise provide a clear API-down message.\n\nStorage\n\n1) No file storage is required for core features.\n2) If later adding charts or snapshots, store generated images in object storage or simple filesystem storage.\n\nDeployment\n\n1) Run as a Node.js server in the cloud.\n2) Use long polling or webhook mode depending on hosting capabilities; both remain within a single process.\n\nOperational tooling (within the same service)\n\n1) Structured logging (request/command context, correlation ids for updates).\n2) Basic internal metrics counters (in-memory) for:\n   1) /price requests\n   2) API successes/failures\n   3) alerts evaluated and triggered\n   4) Telegram send failures\n3) Health endpoints or health logging for readiness/liveness (implementation depends on hosting).",
          "nonFunctional": "Reliability\n\n1) Timeouts on all upstream HTTP calls; fail fast.\n2) Retries with jitter for transient failures (bounded, small count).\n3) Cache responses briefly to reduce load and improve latency.\n4) Scheduler backoff on repeated upstream failures.\n\nCorrectness and alert semantics\n\n1) Alerts are idempotent: once triggered, they are marked triggered to prevent repeats.\n2) Optional crossing detection reduces false triggers when an alert is created while already beyond target.\n3) All comparisons use consistent numeric parsing and rounding strategy; display rounding is separate from evaluation precision.\n\nPerformance\n\n1) Batch price fetching for alert evaluation.\n2) Avoid N+1 database calls by preloading active alerts and grouping them.\n3) Keep watchlists small by design; if large lists are allowed later, switch to per-item documents.\n\nSecurity and abuse prevention\n\n1) Input validation for symbols and target prices.\n2) Basic per-user rate limiting in memory to prevent spam (commands per minute).\n3) Do not log sensitive user content beyond what is required for debugging.\n4) Handle group chats carefully (optional in v1). If enabled, store alerts per chatId and ensure admin-only management if desired.\n\nObservability and operations\n\n1) Log all failures with actionable context (provider status, HTTP status, latency).\n2) Track alert trigger outcomes and Telegram send errors.\n3) Provide an admin-only command set for basic diagnostics (counts, last API error, scheduler status).\n\nUX and accessibility\n\n1) Consistent message format with compact numbers and clear timestamps.\n2) Inline buttons for common next steps:\n   1) Add alert above/below\n   2) Add/remove watchlist\n   3) List alerts\n3) Clear error messages with examples.\n\nData retention\n\n1) Keep triggered alerts for a limited time for user visibility, then optionally auto-archive/delete.\n2) Allow users to delete alerts and watchlist items at any time.\n\nTesting strategy (system-level plan)\n\n1) Unit test domain services (symbol resolution, alert evaluation, caching behavior).\n2) Integration test MongoDB operations for alerts and watchlists.\n3) End-to-end test key Telegram flows with simulated updates.\n4) Load test scheduler logic with many alerts to validate batching and rate limiting."
        },
        "balanceCentsRemaining": 1034072,
        "billing": {
          "ok": true,
          "charged": 49,
          "remaining": 1034072,
          "chargedCents": 49,
          "remainingCents": 1034072,
          "currency": "USD",
          "baseUsd": 0.243704,
          "markupUsd": 0.243704,
          "platformFeeUsd": 0,
          "totalUsd": 0.487408
        },
        "title": "Telegram Crypto Price + Aler"
      }
    }
  },
  "runStatus": {
    "phase": "done",
    "stage": "cold_start",
    "runId": "be818571-5d34-4609-ae28-4cf16dcfa395:mm42nzrv:vuouc6",
    "lastUserMessage": "Build a Telegram crypto price + alerts bot:\n\n- Watchlist: add/remove coins and list watchlist.\n- Price lookup: /price <symbol> (returns price + 24h change).\n- Alerts: set above/below alerts per coin; list and remove alerts.\n- Notifications: alert users when targets are hit.\n- Reliability: caching, graceful errors, and “API down” fallback message.\n- UX: quick inline buttons for common actions (Add alert, Remove, Watchlist).",
    "startedAt": "2026-02-26T23:06:04.899Z",
    "updatedAt": "2026-02-26T23:09:36.856Z",
    "message": "GitHub auto-push skipped (no repo linked or GitHub not connected in session).",
    "commands": [
      {
        "name": "alert",
        "file": "src/commands/alert.js"
      },
      {
        "name": "alerts",
        "file": "src/commands/alerts.js"
      },
      {
        "name": "help",
        "file": "src/commands/help.js"
      },
      {
        "name": "menu",
        "file": "src/commands/menu.js"
      },
      {
        "name": "price",
        "file": "src/commands/price.js"
      },
      {
        "name": "reset",
        "file": "src/commands/reset.js"
      },
      {
        "name": "start",
        "file": "src/commands/start.js"
      },
      {
        "name": "togglewatchlist",
        "file": "src/commands/toggleWatchlist.js"
      },
      {
        "name": "watchlist",
        "file": "src/commands/watchlist.js"
      }
    ],
    "ok": true,
    "state": {
      "projectId": "be818571-5d34-4609-ae28-4cf16dcfa395",
      "fileStructure": {
        ".env.sample": {
          "type": "file",
          "content": "# Telegram\nTELEGRAM_BOT_TOKEN=\n\n# MongoDB (recommended for persistence)\nMONGODB_URI=\n\n# Market data provider\n# Default is CoinGecko v3 API\nCOIN_API_BASE_URL=https://api.coingecko.com/api/v3\n\n# Caching (ms)\nCACHE_TTL_MS=30000\n\n# Alert poller (ms)\nPOLL_INTERVAL_MS=45000\n\n# Logging\nLOG_LEVEL=info\n"
        },
        "CHANGELOG.md": {
          "type": "file",
          "content": "# Changelog\n\nAll notable changes to this bot project are recorded here.\n\n## 2026-02-26 23:09:36. UTC\n- Request: Build a Telegram crypto price + alerts bot: - Watchlist: add/remove coins and list watchlist. - Price lookup: /price <symbol> (returns price + 24h change). - Alerts: set above/below alerts per coin; list and remove aler…\n- Summary: Created a new grammY Telegram bot project for crypto price lookup, watchlists, and polling-based alerts with inline-button UX. Added MongoDB persistence (users/watchlists/alerts), a CoinGecko market data service with ca…\n- Files: .env.sample, DOCS.md, README.md, package.json, project.json, src/bot.js, src/commands/alert.js, src/commands/alerts.js, src/commands/help.js, src/commands/loader.js, src/commands/menu.js, src/commands/price.js, src/commands/reset.js, src/commands/start.js (+1…\n\n"
        },
        "DOCS.md": {
          "type": "file",
          "content": "What this bot does\nThis Telegram bot lets you look up crypto prices, keep a watchlist, and set price alerts that notify you when a coin goes above or below a target price.\n\nPublic commands\n1) /start\nShows a welcome message and a menu with inline buttons.\n\n2) /help\nShows usage examples for prices, watchlists, and alerts.\n\n3) /price <symbol>\nExample: /price BTC\nReplies with current price in USD, 24h percent change, and a timestamp. Includes inline buttons to add alerts and manage your watchlist.\n\n4) /watchlist\nLists your saved symbols. Shows latest cached prices when available. Includes inline remove buttons.\n\n5) /watchlist add <symbol>\nExample: /watchlist add ETH\nAdds the symbol to your watchlist.\n\n6) /watchlist remove <symbol>\nExample: /watchlist remove ETH\nRemoves the symbol from your watchlist.\n\n7) /alerts\nLists your alerts with id, symbol, direction, target, and status. Includes inline remove buttons.\n\n8) /alert add <symbol> above <price>\nExample: /alert add BTC above 70000\nCreates an alert that triggers when current price is greater than or equal to the target.\n\n9) /alert add <symbol> below <price>\nExample: /alert add ETH below 2000\nCreates an alert that triggers when current price is less than or equal to the target.\n\n10) /alert remove <alertId>\nExample: /alert remove 3f9a12c1\nDeletes the alert.\n\n11) /reset\nClears your watchlist and alerts.\n\nInline buttons\n1) Price Lookup: prompts you to use /price <symbol>\n2) My Watchlist: opens your watchlist\n3) My Alerts: opens your alerts\n4) Add Alert ↑ / Add Alert ↓: starts an interactive flow. The bot asks you to send the target price next.\n5) Add to Watchlist / Remove from Watchlist: toggles watchlist membership\n6) Remove alert: deletes the selected alert\n\nAlert behavior\n1) Alerts are polling-based, so notifications may be delayed up to the polling interval.\n2) Alerts trigger once and are kept for history by marking status=triggered and triggeredAt.\n3) If the market data provider is down, the poller logs the error and continues on the next cycle.\n\nMarket data provider\nDefault provider is CoinGecko.\n1) Base URL is configurable via COIN_API_BASE_URL.\n2) Prices are cached per symbol for CACHE_TTL_MS to reduce rate-limited calls.\n3) If the API fails and a cached value exists, the bot may show cached data with a stale note.\n\nEnvironment variables\n1) TELEGRAM_BOT_TOKEN (required)\n2) MONGODB_URI (recommended for persistence)\n3) COIN_API_BASE_URL (optional, default https://api.coingecko.com/api/v3)\n4) CACHE_TTL_MS (optional, default 30000)\n5) POLL_INTERVAL_MS (optional, default 45000)\n6) LOG_LEVEL (optional, default info)\n\nDatabase collections\n1) users: { telegramUserId, createdAt, updatedAt }\n2) watchlists: { telegramUserId, symbols:[\"BTC\"], createdAt, updatedAt }\n3) alerts: { telegramUserId, symbol, direction:\"above\"|\"below\", target:Number, status:\"active\"|\"triggered\", triggeredAt?, createdAt, updatedAt }\n"
        },
        "README.md": {
          "type": "file",
          "content": "This is a Telegram bot (grammY) for crypto price lookup, watchlists, and polling-based price alerts.\n\nFeatures\n1) /price BTC shows current USD price and 24h change\n2) Watchlist: /watchlist, /watchlist add BTC, /watchlist remove BTC\n3) Alerts: /alerts, /alert add BTC above 70000, /alert remove <alertId>\n4) Inline buttons for common actions (add/remove watchlist, remove alerts, start add-alert flow)\n5) Reliability: caching, grouping alert checks by symbol, graceful API-down fallback\n\nArchitecture\n1) src/index.js: boot, env sanity, long polling runner, webhook cleanup\n2) src/bot.js: grammY wiring, command registration, callbacks, interactive flows\n3) src/services/marketData.js: CoinGecko market data + caching\n4) src/services/watchlists.js: Mongo watchlist operations\n5) src/services/alerts.js: Mongo alert operations + evaluation helpers\n6) src/jobs/alertPoller.js: polling loop that triggers notifications\n7) src/lib/db.js: Mongo singleton and indexes\n8) src/lib/log.js: structured, production-safe logs + safeErr()\n\nSetup\n1) Create a Telegram bot token with BotFather.\n2) Copy .env.sample to .env and fill values.\n3) Install deps: npm run install:root\n4) Run locally: npm run dev\n\nEnvironment variables\n1) TELEGRAM_BOT_TOKEN (required): Telegram bot token\n2) MONGODB_URI (optional but recommended): MongoDB connection string for users/watchlists/alerts\n3) COIN_API_BASE_URL (optional): market data base URL (default: https://api.coingecko.com/api/v3)\n4) CACHE_TTL_MS (optional): price cache ttl (default: 30000)\n5) POLL_INTERVAL_MS (optional): alert polling interval (default: 45000)\n6) LOG_LEVEL (optional): debug|info|warn|error (default: info)\n\nCommands (examples)\n1) /start\n2) /help\n3) /price BTC\n4) /watchlist\n5) /watchlist add BTC\n6) /watchlist remove BTC\n7) /alerts\n8) /alert add BTC above 70000\n9) /alert add ETH below 2000\n10) /alert remove <alertId>\n11) /reset (clear your stored watchlist and alerts)\n\nDeployment notes (Render)\n1) Use a Background Worker (or any always-on Node service).\n2) Set TELEGRAM_BOT_TOKEN.\n3) Set MONGODB_URI for persistence.\n4) Build command should run: npm run build\n5) Start command: npm start\n\nTroubleshooting\n1) If the bot starts but doesn’t respond, verify TELEGRAM_BOT_TOKEN is set.\n2) If alerts don’t trigger, check logs for poller cycles and market API failures.\n3) If market API is down, /price will return a consistent fallback message.\n"
        },
        "package.json": {
          "type": "file",
          "content": "{\n  \"name\": \"cookmybots-telegram-bot\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"scripts\": {\n    \"install:root\": \"bash -lc \\\"set -e; if [ -f package-lock.json ]; then npm ci; else npm install; fi\\\"\",\n    \"build\": \"npm run install:root && echo build\",\n    \"start\": \"node src/index.js\",\n    \"dev\": \"node --watch src/index.js\"\n  },\n  \"dependencies\": {\n    \"dotenv\": \"^16.4.5\",\n    \"grammy\": \"^1.20.0\",\n    \"mongodb\": \"^6.10.0\",\n    \"@grammyjs/runner\": \"^2.0.3\"\n  },\n  \"devDependencies\": {}\n}\n"
        },
        "src": {
          "type": "dir",
          "children": {
            "bot.js": {
              "type": "file",
              "content": "import { Bot } from \"grammy\";\nimport { maybeHandleAlertFlowMessage } from \"./features/alertFlow.js\";\n\nexport function createBot(token, deps) {\n  const bot = new Bot(token);\n\n  bot.on(\"message:text\", async (ctx, next) => {\n    const raw = String(ctx.message?.text || \"\");\n    if (raw.startsWith(\"/\")) return next();\n\n    const handled = await maybeHandleAlertFlowMessage(ctx, deps);\n    if (handled) return;\n\n    return next();\n  });\n\n  return bot;\n}\n"
            },
            "commands": {
              "type": "dir",
              "children": {
                "alert.js": {
                  "type": "file",
                  "content": "import { createAlert, normalizeDirection, parseTargetPrice, removeAlert } from \"../services/alerts.js\";\nimport { startAlertFlow } from \"../features/alertFlow.js\";\n\nexport default function register(bot, { cfg, log }) {\n  bot.command(\"alert\", async (ctx) => {\n    const userId = ctx.from?.id;\n    if (!cfg.MONGODB_URI) {\n      await ctx.reply(\"Alerts need a database connection. The bot is running in limited mode right now.\");\n      return;\n    }\n    if (!userId) {\n      await ctx.reply(\"I couldn’t identify your user id.\");\n      return;\n    }\n\n    const parts = String(ctx.match || \"\").trim().split(/\\s+/).filter(Boolean);\n    const sub = String(parts[0] || \"\").toLowerCase();\n\n    if (sub === \"add\") {\n      const symbol = String(parts[1] || \"\").trim().toUpperCase();\n      const direction = normalizeDirection(parts[2]);\n      const target = parseTargetPrice(parts[3]);\n\n      if (!symbol || !direction || !target) {\n        await ctx.reply(\"Usage: /alert add BTC above 70000\\nOr: /alert add ETH below 2000\");\n        return;\n      }\n\n      const r = await createAlert({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol, direction, target });\n      if (!r.ok) {\n        await ctx.reply(\"Sorry, I couldn’t create that alert. Please try again.\");\n        return;\n      }\n\n      await ctx.reply(`Alert created: ${String(r.id).slice(0, 8)}`);\n      return;\n    }\n\n    if (sub === \"remove\") {\n      const id = String(parts[1] || \"\").trim();\n      if (!id) {\n        await ctx.reply(\"Usage: /alert remove <alertId>\");\n        return;\n      }\n      const r = await removeAlert({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, alertId: id });\n      if (!r.ok) {\n        await ctx.reply(\"I couldn’t remove that alert. Check the id and try again.\");\n        return;\n      }\n      await ctx.reply(r.removed ? \"Alert removed.\" : \"Alert not found.\");\n      return;\n    }\n\n    await ctx.reply(\"Usage:\\n/alert add BTC above 70000\\n/alert add ETH below 2000\\n/alert remove <alertId>\");\n  });\n\n  bot.callbackQuery(/^aa:([A-Z0-9]{1,15}):(above|below)$/, async (ctx) => {\n    const userId = ctx.from?.id;\n    await ctx.answerCallbackQuery();\n    if (!userId) return;\n\n    const symbol = String(ctx.match?.[1] || \"\").trim().toUpperCase();\n    const direction = String(ctx.match?.[2] || \"\").trim().toLowerCase();\n\n    if (!cfg.MONGODB_URI) {\n      await ctx.reply(\"Alerts need a database connection.\");\n      return;\n    }\n\n    startAlertFlow({ userId, symbol, direction });\n    await ctx.reply(`Send target price for ${symbol} (${direction}).\\nExample: 70000\\n\\nYou can type cancel to stop.`);\n  });\n}\n"
                },
                "alerts.js": {
                  "type": "file",
                  "content": "import { InlineKeyboard } from \"grammy\";\nimport { listAlerts, removeAlert } from \"../services/alerts.js\";\nimport { fmtUsd, shortId } from \"../lib/format.js\";\n\nexport default function register(bot, { cfg, log }) {\n  bot.command(\"alerts\", async (ctx) => {\n    const userId = ctx.from?.id;\n    if (!cfg.MONGODB_URI) {\n      await ctx.reply(\"Alerts need a database connection. The bot is running in limited mode right now.\");\n      return;\n    }\n    if (!userId) {\n      await ctx.reply(\"I couldn’t identify your user id.\");\n      return;\n    }\n\n    const r = await listAlerts({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId });\n    if (!r.ok) {\n      await ctx.reply(\"Sorry, I couldn’t load your alerts right now.\");\n      return;\n    }\n\n    if (r.alerts.length === 0) {\n      await ctx.reply(\"You have no alerts. Example: /alert add BTC above 70000\");\n      return;\n    }\n\n    const lines = [\"Your alerts:\"];\n    const kb = new InlineKeyboard();\n\n    for (const a of r.alerts.slice(0, 30)) {\n      const created = a.createdAt ? new Date(a.createdAt).toLocaleString() : \"\";\n      const t = `${shortId(a.id)} | ${a.symbol} ${a.direction} ${fmtUsd(a.target)} | ${a.status}${created ? \" | \" + created : \"\"}`;\n      lines.push(t);\n      kb.text(`Remove ${shortId(a.id)}`, `ar:${a.id}`).row();\n    }\n\n    await ctx.reply(lines.join(\"\\n\"), { reply_markup: kb });\n  });\n\n  bot.callbackQuery(/^ar:([a-f0-9]{24})$/, async (ctx) => {\n    const userId = ctx.from?.id;\n    await ctx.answerCallbackQuery();\n\n    if (!cfg.MONGODB_URI || !userId) {\n      await ctx.reply(\"Alerts need a database connection.\");\n      return;\n    }\n\n    const alertId = ctx.match?.[1];\n    const r = await removeAlert({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, alertId });\n    if (!r.ok) {\n      await ctx.reply(\"I couldn’t remove that alert. It may already be gone.\");\n      return;\n    }\n\n    await ctx.reply(r.removed ? \"Alert removed.\" : \"Alert not found.\");\n  });\n}\n"
                },
                "help.js": {
                  "type": "file",
                  "content": "export default function register(bot) {\n  bot.command(\"help\", async (ctx) => {\n    await ctx.reply(\n      [\n        \"Commands and examples:\",\n        \"/price BTC\",\n        \"/watchlist\",\n        \"/watchlist add BTC\",\n        \"/watchlist remove BTC\",\n        \"/alerts\",\n        \"/alert add BTC above 70000\",\n        \"/alert add ETH below 2000\",\n        \"/alert remove <alertId>\",\n        \"\",\n        \"Alerts are polling-based. A notification is sent when the target is hit, and it can be delayed by the polling interval.\",\n      ].join(\"\\n\")\n    );\n  });\n}\n"
                },
                "loader.js": {
                  "type": "file",
                  "content": "import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { fileURLToPath, pathToFileURL } from \"node:url\";\n\nexport async function registerCommands(bot, deps = {}) {\n  const dir = path.dirname(fileURLToPath(import.meta.url));\n\n  const commandFiles = fs\n    .readdirSync(dir)\n    .filter((file) => file.endsWith(\".js\") && file !== \"loader.js\" && !file.startsWith(\"_\"))\n    .sort();\n\n  for (const file of commandFiles) {\n    const modUrl = pathToFileURL(path.join(dir, file)).href;\n    const mod = await import(modUrl);\n\n    const handler = mod?.default || mod?.register;\n    if (typeof handler === \"function\") {\n      await handler(bot, deps);\n    } else {\n      console.warn(\"[commands] skipped\", { file });\n    }\n  }\n}\n"
                },
                "menu.js": {
                  "type": "file",
                  "content": "export default function register(bot) {\n  bot.callbackQuery(/^menu:(price|watchlist|alerts|help)$/, async (ctx) => {\n    const which = ctx.match?.[1];\n    await ctx.answerCallbackQuery();\n\n    if (which === \"price\") {\n      await ctx.reply(\"Send /price <symbol> مثلا: /price BTC\");\n      return;\n    }\n    if (which === \"watchlist\") {\n      await ctx.reply(\"Send /watchlist to view your watchlist.\");\n      return;\n    }\n    if (which === \"alerts\") {\n      await ctx.reply(\"Send /alerts to view your alerts.\");\n      return;\n    }\n    if (which === \"help\") {\n      await ctx.reply(\"Send /help to see all commands.\");\n      return;\n    }\n  });\n}\n"
                },
                "price.js": {
                  "type": "file",
                  "content": "import { InlineKeyboard } from \"grammy\";\nimport { fmtUsd, fmtPct } from \"../lib/format.js\";\nimport { hasInWatchlist } from \"../services/watchlists.js\";\n\nconst API_DOWN_FALLBACK = \"Market data is temporarily unavailable. Please try again later.\";\n\nfunction normalizeSymbol(symbol) {\n  return String(symbol || \"\").trim().toUpperCase();\n}\n\nexport default function register(bot, { cfg, log, market }) {\n  bot.command(\"price\", async (ctx) => {\n    const userId = ctx.from?.id;\n    const raw = ctx.match;\n    const sym = normalizeSymbol(raw);\n\n    if (!sym) {\n      await ctx.reply(\"Usage: /price BTC\");\n      return;\n    }\n\n    const q = await market.getQuoteBySymbol(sym, { allowStale: true });\n\n    if (!q.ok) {\n      if (q.reason === \"unknown_symbol\") {\n        await ctx.reply(`I don’t recognize the symbol ${sym}. Try something like BTC, ETH, or SOL.`);\n        return;\n      }\n      await ctx.reply(API_DOWN_FALLBACK);\n      return;\n    }\n\n    let watch = { ok: false, has: false };\n    if (cfg.MONGODB_URI && userId) {\n      watch = await hasInWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n    }\n\n    const staleNote = q.stale ? \"\\n\\nNote: showing cached data (API may be down).\" : \"\";\n    const ts = q.ts ? new Date(q.ts) : new Date();\n\n    const lines = [\n      `${q.name || sym} (${sym})`,\n      `Price: ${fmtUsd(q.priceUsd)}`,\n      `24h: ${q.change24hPct == null ? \"N/A\" : fmtPct(q.change24hPct)}`,\n      `As of: ${ts.toLocaleString()}`,\n    ];\n\n    const kb = new InlineKeyboard();\n    kb.text(\"Add Alert ↑\", `aa:${sym}:above`).text(\"Add Alert ↓\", `aa:${sym}:below`).row();\n\n    if (cfg.MONGODB_URI && userId) {\n      kb.text(watch.ok && watch.has ? \"Remove from Watchlist\" : \"Add to Watchlist\", `wt:${sym}`).row();\n    }\n\n    kb.text(\"View Watchlist\", \"menu:watchlist\").text(\"View Alerts\", \"menu:alerts\");\n\n    await ctx.reply(lines.join(\"\\n\") + staleNote, { reply_markup: kb });\n  });\n\n  bot.callbackQuery(/^px:([A-Z0-9]{1,15})$/, async (ctx) => {\n    const sym = normalizeSymbol(ctx.match?.[1]);\n    await ctx.answerCallbackQuery();\n    await ctx.reply(`/price ${sym}`);\n  });\n}\n"
                },
                "reset.js": {
                  "type": "file",
                  "content": "import { clearWatchlist } from \"../services/watchlists.js\";\nimport { clearAlerts } from \"../services/alerts.js\";\n\nexport default function register(bot, { cfg, log }) {\n  bot.command(\"reset\", async (ctx) => {\n    const userId = ctx.from?.id;\n    if (!cfg.MONGODB_URI) {\n      await ctx.reply(\"Nothing to reset because MONGODB_URI is not set.\");\n      return;\n    }\n    if (!userId) {\n      await ctx.reply(\"I couldn’t identify your user id.\");\n      return;\n    }\n\n    await clearWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId });\n    await clearAlerts({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId });\n\n    await ctx.reply(\"Done. Your watchlist and alerts were cleared.\");\n  });\n}\n"
                },
                "start.js": {
                  "type": "file",
                  "content": "import { InlineKeyboard } from \"grammy\";\nimport { upsertUser } from \"../services/users.js\";\n\nexport default function register(bot, { cfg, log }) {\n  bot.command(\"start\", async (ctx) => {\n    const userId = ctx.from?.id;\n    const chatId = ctx.chat?.id;\n\n    if (userId) {\n      await upsertUser({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, chatId });\n    }\n\n    const kb = new InlineKeyboard()\n      .text(\"Price Lookup\", \"menu:price\").row()\n      .text(\"My Watchlist\", \"menu:watchlist\").row()\n      .text(\"My Alerts\", \"menu:alerts\").row()\n      .text(\"Help\", \"menu:help\");\n\n    const extra = cfg.MONGODB_URI ? \"\" : \"\\n\\nNote: MONGODB_URI is not set, so watchlists and alerts are disabled.\";\n\n    await ctx.reply(\n      \"Welcome. I can look up crypto prices, manage a watchlist, and send price alerts.\\n\\nSymbols are simple tickers like BTC or ETH. Prices come from a market data provider.\" + extra,\n      { reply_markup: kb }\n    );\n  });\n}\n"
                },
                "toggleWatchlist.js": {
                  "type": "file",
                  "content": "import { addToWatchlist, removeFromWatchlist, hasInWatchlist } from \"../services/watchlists.js\";\n\nfunction normalizeSymbol(symbol) {\n  return String(symbol || \"\").trim().toUpperCase();\n}\n\nexport default function register(bot, { cfg, log }) {\n  bot.callbackQuery(/^wt:([A-Z0-9]{1,15})$/, async (ctx) => {\n    const userId = ctx.from?.id;\n    const sym = normalizeSymbol(ctx.match?.[1]);\n    await ctx.answerCallbackQuery();\n\n    if (!cfg.MONGODB_URI || !userId) {\n      await ctx.reply(\"Watchlists need a database connection.\");\n      return;\n    }\n\n    const h = await hasInWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n    if (h.ok && h.has) {\n      await removeFromWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n      await ctx.reply(`Removed ${sym} from your watchlist.`);\n      return;\n    }\n\n    await addToWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n    await ctx.reply(`Added ${sym} to your watchlist.`);\n  });\n}\n"
                },
                "watchlist.js": {
                  "type": "file",
                  "content": "import { InlineKeyboard } from \"grammy\";\nimport { getWatchlist, addToWatchlist, removeFromWatchlist, clearWatchlist } from \"../services/watchlists.js\";\nimport { fmtUsd, fmtPct } from \"../lib/format.js\";\n\nfunction normalizeSymbol(symbol) {\n  return String(symbol || \"\").trim().toUpperCase();\n}\n\nexport default function register(bot, { cfg, log, market }) {\n  bot.command(\"watchlist\", async (ctx) => {\n    const userId = ctx.from?.id;\n    if (!cfg.MONGODB_URI) {\n      await ctx.reply(\"Watchlists need a database connection. The bot is running in limited mode right now.\");\n      return;\n    }\n    if (!userId) {\n      await ctx.reply(\"I couldn’t identify your user id.\");\n      return;\n    }\n\n    const parts = String(ctx.match || \"\").trim().split(/\\s+/).filter(Boolean);\n    const sub = String(parts[0] || \"\").toLowerCase();\n\n    if (sub === \"add\") {\n      const sym = normalizeSymbol(parts[1]);\n      if (!sym) {\n        await ctx.reply(\"Usage: /watchlist add BTC\");\n        return;\n      }\n      const r = await addToWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n      if (!r.ok) {\n        await ctx.reply(\"Sorry, I couldn’t update your watchlist. Please try again.\");\n        return;\n      }\n      await ctx.reply(`Added ${sym} to your watchlist.`);\n      await showWatchlist(ctx, { cfg, log, market, userId });\n      return;\n    }\n\n    if (sub === \"remove\") {\n      const sym = normalizeSymbol(parts[1]);\n      if (!sym) {\n        await ctx.reply(\"Usage: /watchlist remove BTC\");\n        return;\n      }\n      const r = await removeFromWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n      if (!r.ok) {\n        await ctx.reply(\"Sorry, I couldn’t update your watchlist. Please try again.\");\n        return;\n      }\n      await ctx.reply(`Removed ${sym} from your watchlist.`);\n      await showWatchlist(ctx, { cfg, log, market, userId });\n      return;\n    }\n\n    await showWatchlist(ctx, { cfg, log, market, userId });\n  });\n\n  bot.callbackQuery(/^wr:([A-Z0-9]{1,15})$/, async (ctx) => {\n    const userId = ctx.from?.id;\n    const sym = normalizeSymbol(ctx.match?.[1]);\n    await ctx.answerCallbackQuery();\n\n    if (!cfg.MONGODB_URI || !userId) {\n      await ctx.reply(\"Watchlists need a database connection.\");\n      return;\n    }\n\n    await removeFromWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId, symbol: sym });\n    await ctx.reply(`Removed ${sym} from your watchlist.`);\n  });\n\n  bot.callbackQuery(/^wc$/, async (ctx) => {\n    const userId = ctx.from?.id;\n    await ctx.answerCallbackQuery();\n\n    if (!cfg.MONGODB_URI || !userId) {\n      await ctx.reply(\"Watchlists need a database connection.\");\n      return;\n    }\n\n    await clearWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId });\n    await ctx.reply(\"Watchlist cleared.\");\n  });\n}\n\nasync function showWatchlist(ctx, { cfg, log, market, userId }) {\n  const wl = await getWatchlist({ mongoUri: cfg.MONGODB_URI, log, telegramUserId: userId });\n  if (!wl.ok) {\n    await ctx.reply(\"Sorry, I couldn’t load your watchlist right now.\");\n    return;\n  }\n\n  if (wl.symbols.length === 0) {\n    await ctx.reply(\"Your watchlist is empty. Add one with /watchlist add BTC.\");\n    return;\n  }\n\n  const quotes = await market.getQuotesForSymbols(wl.symbols);\n\n  const lines = [\"Your watchlist:\"];\n  for (const sym of wl.symbols) {\n    const q = quotes.get(sym);\n    if (q?.ok) {\n      const change = q.change24hPct == null ? \"\" : ` (${fmtPct(q.change24hPct)})`;\n      const stale = q.stale ? \" [cached]\" : \"\";\n      lines.push(`${sym}: ${fmtUsd(q.priceUsd)}${change}${stale}`);\n    } else {\n      lines.push(`${sym}: (no data right now)`);\n    }\n  }\n\n  const kb = new InlineKeyboard();\n  for (const sym of wl.symbols.slice(0, 20)) {\n    kb.text(`Remove ${sym}`, `wr:${sym}`).row();\n  }\n  kb.text(\"Clear\", \"wc\");\n\n  await ctx.reply(lines.join(\"\\n\"), { reply_markup: kb });\n}\n"
                }
              }
            },
            "features": {
              "type": "dir",
              "children": {
                "alertFlow.js": {
                  "type": "file",
                  "content": "import { parseTargetPrice, createAlert } from \"../services/alerts.js\";\n\nconst TTL_MS = 120_000;\n\nconst flows = new Map();\n\nfunction now() {\n  return Date.now();\n}\n\nfunction keyFor(userId) {\n  return String(userId || \"\");\n}\n\nexport function startAlertFlow({ userId, symbol, direction }) {\n  const k = keyFor(userId);\n  flows.set(k, {\n    symbol: String(symbol || \"\").trim().toUpperCase(),\n    direction: String(direction || \"\").trim().toLowerCase(),\n    expiresAt: now() + TTL_MS,\n  });\n}\n\nexport function clearAlertFlow(userId) {\n  flows.delete(keyFor(userId));\n}\n\nexport function getAlertFlow(userId) {\n  const k = keyFor(userId);\n  const f = flows.get(k);\n  if (!f) return null;\n  if (f.expiresAt <= now()) {\n    flows.delete(k);\n    return null;\n  }\n  return f;\n}\n\nexport async function maybeHandleAlertFlowMessage(ctx, { mongoUri, log }) {\n  const userId = ctx.from?.id;\n  if (!userId) return false;\n\n  const f = getAlertFlow(userId);\n  if (!f) return false;\n\n  const text = String(ctx.message?.text || \"\").trim();\n  if (!text) return true;\n\n  if (/^(cancel|stop|never mind|nevermind)$/i.test(text)) {\n    clearAlertFlow(userId);\n    await ctx.reply(\"Cancelled. If you want to add an alert, use /alert add BTC above 70000 or tap Add Alert from a price message.\");\n    return true;\n  }\n\n  const target = parseTargetPrice(text);\n  if (!target) {\n    await ctx.reply(`Please send a valid number for the target price (USD), or type cancel.`);\n    return true;\n  }\n\n  clearAlertFlow(userId);\n\n  const created = await createAlert({\n    mongoUri,\n    log,\n    telegramUserId: userId,\n    symbol: f.symbol,\n    direction: f.direction,\n    target,\n  });\n\n  if (!created.ok) {\n    if (created.reason === \"no_db\") {\n      await ctx.reply(\"Alerts need a database connection. The bot is running in limited mode right now.\");\n      return true;\n    }\n    await ctx.reply(\"Sorry, I couldn’t create that alert. Please try again.\");\n    return true;\n  }\n\n  const idShort = String(created.id).slice(0, 8);\n  await ctx.reply(`Alert created: ${idShort}\\n${f.symbol} ${f.direction} ${target}`);\n  return true;\n}\n"
                }
              }
            },
            "index.js": {
              "type": "file",
              "content": "import \"dotenv/config\";\n\nimport { run } from \"@grammyjs/runner\";\n\nimport { cfg } from \"./lib/config.js\";\nimport { createLogger, safeErr } from \"./lib/log.js\";\nimport { createBot } from \"./bot.js\";\nimport { registerCommands } from \"./commands/loader.js\";\nimport { getDb, closeDb } from \"./lib/db.js\";\nimport { MarketDataService } from \"./services/marketData.js\";\nimport { startAlertPoller } from \"./jobs/alertPoller.js\";\nimport { buildBotProfile } from \"./lib/botProfile.js\";\n\nprocess.on(\"unhandledRejection\", (r) => {\n  console.error(\"UnhandledRejection:\", r);\n  process.exit(1);\n});\nprocess.on(\"uncaughtException\", (e) => {\n  console.error(\"UncaughtException:\", e);\n  process.exit(1);\n});\n\nasync function boot() {\n  const log = createLogger({ level: cfg.LOG_LEVEL });\n\n  log.info(\"boot start\", {\n    nodeEnv: process.env.NODE_ENV || \"\",\n    TELEGRAM_BOT_TOKEN_set: !!cfg.TELEGRAM_BOT_TOKEN,\n    MONGODB_URI_set: !!cfg.MONGODB_URI,\n    COIN_API_BASE_URL_set: !!cfg.COIN_API_BASE_URL,\n  });\n\n  if (!cfg.TELEGRAM_BOT_TOKEN) {\n    console.error(\"TELEGRAM_BOT_TOKEN is required. Add it to your env and redeploy.\");\n    process.exit(1);\n  }\n\n  const bot = createBot(cfg.TELEGRAM_BOT_TOKEN, { mongoUri: cfg.MONGODB_URI, log });\n\n  try {\n    await bot.init();\n  } catch (e) {\n    log.warn(\"bot init failed\", { err: safeErr(e) });\n  }\n\n  const db = await getDb(cfg.MONGODB_URI, log);\n  if (!db && cfg.MONGODB_URI) {\n    log.warn(\"db unavailable, running in limited mode\", { mongo: false });\n  }\n\n  const market = new MarketDataService({\n    baseUrl: cfg.COIN_API_BASE_URL,\n    cacheTtlMs: cfg.CACHE_TTL_MS,\n    log,\n  });\n\n  const botProfile = buildBotProfile();\n  log.info(\"bot profile\", { chars: botProfile.length });\n\n  await registerCommands(bot, { cfg, log, market, mongoUri: cfg.MONGODB_URI, botProfile });\n\n  try {\n    await bot.api.setMyCommands([\n      { command: \"start\", description: \"Welcome and menu\" },\n      { command: \"help\", description: \"How to use the bot\" },\n      { command: \"price\", description: \"Get price for a symbol\" },\n      { command: \"watchlist\", description: \"Manage your watchlist\" },\n      { command: \"alerts\", description: \"List your alerts\" },\n      { command: \"alert\", description: \"Add/remove an alert\" },\n      { command: \"reset\", description: \"Clear watchlist and alerts\" },\n    ]);\n  } catch (e) {\n    log.warn(\"setMyCommands failed\", { err: safeErr(e) });\n  }\n\n  let poller = null;\n\n  async function startPollingWithRetry() {\n    let delay = 2000;\n    const maxDelay = 20000;\n    let runner = null;\n\n    for (;;) {\n      try {\n        log.info(\"polling start\", { runnerConcurrency: 1 });\n\n        try {\n          await bot.api.deleteWebhook({ drop_pending_updates: true });\n        } catch (e) {\n          log.warn(\"deleteWebhook failed\", { err: safeErr(e) });\n        }\n\n        runner = run(bot, { runner: { concurrency: 1 } });\n        log.info(\"polling running\");\n\n        poller = startAlertPoller({ bot, cfg, log, market });\n\n        await runner.task();\n\n        log.warn(\"polling stopped unexpectedly, restarting\");\n      } catch (e) {\n        const msg = safeErr(e);\n        const is409 = String(msg).includes(\"409\") || String(msg).toLowerCase().includes(\"conflict\");\n        log.warn(\"polling error\", { err: msg, is409, delayMs: delay });\n      }\n\n      try {\n        poller?.stop?.();\n      } catch {}\n      poller = null;\n\n      await new Promise((r) => setTimeout(r, delay));\n      delay = Math.min(maxDelay, Math.floor(delay * 1.7));\n    }\n  }\n\n  await startPollingWithRetry();\n\n  async function shutdown() {\n    try {\n      poller?.stop?.();\n    } catch {}\n    await closeDb(log);\n  }\n\n  process.on(\"SIGINT\", () => shutdown().finally(() => process.exit(0)));\n  process.on(\"SIGTERM\", () => shutdown().finally(() => process.exit(0)));\n}\n\nboot().catch((e) => {\n  console.error(\"Boot error:\", safeErr(e));\n  process.exit(1);\n});\n"
            },
            "jobs": {
              "type": "dir",
              "children": {
                "alertPoller.js": {
                  "type": "file",
                  "content": "import { safeErr } from \"../lib/log.js\";\nimport { loadActiveAlerts, markTriggered } from \"../services/alerts.js\";\nimport { fmtUsd } from \"../lib/format.js\";\n\nfunction sleep(ms) {\n  return new Promise((r) => setTimeout(r, ms));\n}\n\nexport function startAlertPoller({ bot, cfg, log, market }) {\n  const intervalMs = Number.isFinite(cfg.POLL_INTERVAL_MS) && cfg.POLL_INTERVAL_MS > 0 ? cfg.POLL_INTERVAL_MS : 45_000;\n\n  let stopped = false;\n  let running = false;\n  let cycles = 0;\n  let backoffMs = 0;\n\n  async function cycle() {\n    if (stopped || running) return;\n    running = true;\n    const started = Date.now();\n\n    try {\n      log.info(\"poller cycle start\", { intervalMs, backoffMs });\n\n      if (backoffMs > 0) {\n        await sleep(backoffMs);\n        backoffMs = 0;\n      }\n\n      const r = await loadActiveAlerts({ mongoUri: cfg.MONGODB_URI, log });\n      const alerts = r.ok ? r.alerts : [];\n\n      if (!r.ok) {\n        log.warn(\"poller load alerts failed\", { reason: r.reason });\n        return;\n      }\n\n      const uniqueSymbols = [...new Set(alerts.map((a) => a.symbol))];\n      const quotes = await market.getQuotesForSymbols(uniqueSymbols);\n\n      let checked = 0;\n      let triggered = 0;\n\n      for (const a of alerts) {\n        checked++;\n        const q = quotes.get(a.symbol);\n        if (!q || !q.ok) continue;\n\n        const price = q.priceUsd;\n        const hit = a.direction === \"above\" ? price >= a.target : price <= a.target;\n        if (!hit) continue;\n\n        triggered++;\n\n        try {\n          await markTriggered({ mongoUri: cfg.MONGODB_URI, log, alertId: a.id, currentPrice: price });\n\n          const idShort = String(a.id).slice(0, 8);\n          const msg = [\n            `Price alert triggered (${idShort})`,\n            `${a.symbol} is ${fmtUsd(price)}`,\n            `Target was ${a.direction} ${fmtUsd(a.target)}`,\n          ].join(\"\\n\");\n\n          await bot.api.sendMessage(Number(a.telegramUserId), msg, {\n            reply_markup: {\n              inline_keyboard: [\n                [\n                  { text: \"View Price\", callback_data: `px:${a.symbol}` },\n                  { text: \"Remove Alert\", callback_data: `ar:${a.id}` },\n                ],\n                [\n                  { text: \"New Alert ↑\", callback_data: `aa:${a.symbol}:above` },\n                  { text: \"New Alert ↓\", callback_data: `aa:${a.symbol}:below` },\n                ],\n              ],\n            },\n          });\n        } catch (e) {\n          log.warn(\"poller notify failed\", { userId: a.telegramUserId, err: safeErr(e) });\n        }\n      }\n\n      const ms = Date.now() - started;\n      log.info(\"poller cycle end\", { checked, triggered, symbols: uniqueSymbols.length, ms });\n\n      cycles++;\n      if (cycles % Math.max(1, Math.floor(60_000 / intervalMs)) === 0) {\n        const m = process.memoryUsage();\n        console.log(\"[mem]\", { rssMB: Math.round(m.rss / 1e6), heapUsedMB: Math.round(m.heapUsed / 1e6) });\n      }\n    } catch (e) {\n      log.error(\"poller cycle error\", { err: safeErr(e) });\n      backoffMs = Math.min(20_000, Math.max(2_000, (backoffMs || 2_000) * 2));\n    } finally {\n      running = false;\n    }\n  }\n\n  log.info(\"poller started\", { intervalMs });\n  const t = setInterval(() => {\n    cycle().catch((e) => log.error(\"poller tick error\", { err: safeErr(e) }));\n  }, intervalMs);\n\n  cycle().catch((e) => log.error(\"poller first cycle error\", { err: safeErr(e) }));\n\n  return {\n    stop: () => {\n      stopped = true;\n      clearInterval(t);\n      log.info(\"poller stopped\");\n    },\n  };\n}\n"
                }
              }
            },
            "lib": {
              "type": "dir",
              "children": {
                "ai.js": {
                  "type": "file",
                  "content": "function trimSlash(u) {\n  u = String(u || \"\");\n  while (u.endsWith(\"/\")) u = u.slice(0, -1);\n  return u;\n}\n\nfunction sleep(ms) {\n  return new Promise((r) => setTimeout(r, ms));\n}\n\nasync function safeRead(r) {\n  const text = await r.text();\n  let json = null;\n  try { json = JSON.parse(text); } catch {}\n  return { text, json };\n}\n\nfunction notConfigured(message) {\n  return { ok: false, status: 412, json: null, text: \"\", error: message };\n}\n\nfunction withTimeout(ms) {\n  const ctrl = new AbortController();\n  const t = setTimeout(() => ctrl.abort(), ms);\n  return { ctrl, clear: () => clearTimeout(t) };\n}\n\nfunction pickTimeout(cfg) {\n  const v = Number(cfg?.AI_TIMEOUT_MS || cfg?.AI_TIMEOUT || 20000);\n  return Number.isFinite(v) && v > 0 ? v : 20000;\n}\n\nfunction pickModel(cfg, override) {\n  const m = String(override || cfg?.AI_MODEL || \"\").trim();\n  return m || undefined;\n}\n\nfunction isRetryableStatus(status) {\n  // 408: request timeout, 429: rate, 500/502/503/504 transient\n  return status === 408 || status === 429 || status === 500 || status === 502 || status === 503 || status === 504;\n}\n\nfunction redact(s) {\n  s = String(s || \"\");\n  if (s.length <= 400) return s;\n  return s.slice(0, 400) + \"…\";\n}\n\nfunction web3Mode(cfg) {\n  const m = String(cfg?.WEB3_CHAT_MODE || \"auto\").trim().toLowerCase();\n  return (m === \"on\" || m === \"off\" || m === \"auto\") ? m : \"auto\";\n}\n\nasync function aiGet(cfg, path, opts = {}) {\n  const base = trimSlash(cfg?.COOKMYBOTS_AI_ENDPOINT || \"\");\n  const key = String(cfg?.COOKMYBOTS_AI_KEY || \"\");\n  const DEBUG = String(cfg?.AI_DEBUG || \"\") === \"1\";\n  if (!base || !key) return notConfigured(\"AI_NOT_CONFIGURED (missing COOKMYBOTS_AI_ENDPOINT/COOKMYBOTS_AI_KEY)\");\n\n  const timeoutMs = Number(opts.timeoutMs || pickTimeout(cfg));\n  const url = base + String(path || \"\");\n\n  const { ctrl, clear } = withTimeout(timeoutMs);\n  try {\n    if (DEBUG) console.log(\"[aiGet] ->\", url);\n    const r = await fetch(url, { method: \"GET\", headers: { Authorization: \"Bearer \" + key }, signal: ctrl.signal });\n    const { text, json } = await safeRead(r);\n    if (!r.ok) {\n      const err = json?.error || json?.message || text || \"AI_ERROR\";\n      return { ok: false, status: r.status, json, text, error: String(err) };\n    }\n    return { ok: true, status: r.status, json, text, error: null };\n  } catch (e) {\n    const msg = e?.name === \"AbortError\" ? \"AI_TIMEOUT\" : (e?.message || \"AI_NETWORK_ERROR\");\n    return { ok: false, status: e?.name === \"AbortError\" ? 408 : 0, json: null, text: \"\", error: String(msg) };\n  } finally {\n    clear();\n  }\n}\n\nasync function routeChat(cfg, userText, systemHint) {\n  // Uses the normal gateway /chat as a fast classifier.\n  // Returns: \"web3\" | \"normal\"\n  const base = trimSlash(cfg?.COOKMYBOTS_AI_ENDPOINT || \"\");\n  const key = String(cfg?.COOKMYBOTS_AI_KEY || \"\");\n  if (!base || !key) return \"normal\";\n\n  const timeoutMs = Math.min(8000, pickTimeout(cfg));\n  const { ctrl, clear } = withTimeout(timeoutMs);\n\n  const sys = [\n    \"You are a routing classifier for a bot.\",\n    \"Decide if the user's message should go to a Web3 specialist model (ChainGPT) or a normal general AI model.\",\n    \"\",\n    \"Return ONLY valid JSON:\",\n    '{\"route\":\"web3\"}',\n    \"or\",\n    '{\"route\":\"normal\"}',\n    \"\",\n    \"Route to web3 if the user asks about: crypto, tokens, Solidity, smart contracts, audits, DeFi, NFTs, wallets, chains, bridges, gas, DEXs, on-chain tools or anything related to blockchain.\",\n    \"Otherwise route to normal.\",\n    \"\",\n    \"Extra context (bot/system hint):\",\n    String(systemHint || \"\").slice(0, 800),\n  ].join(\"\n\");\n\n  try {\n    const r = await fetch(base + \"/chat\", {\n      method: \"POST\",\n      headers: {\n        Authorization: \"Bearer \" + key,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        messages: [\n          { role: \"system\", content: sys },\n          { role: \"user\", content: String(userText || \"\").slice(0, 2000) },\n        ],\n        model: pickModel(cfg, \"\"), // let gateway default or AI_MODEL\n        meta: { purpose: \"route\" },\n      }),\n      signal: ctrl.signal,\n    });\n\n    const { text, json } = await safeRead(r);\n    if (!r.ok) return \"normal\";\n\n    // Try common shapes: gateway might return {text} or OpenAI-like {choices}\n    const out =\n      (json && (json.text || json.message)) ||\n      (json && json.choices && json.choices[0] && json.choices[0].message && json.choices[0].message.content) ||\n      text ||\n      \"\";\n\n    const raw = String(out || \"\").trim();\n\n    // Parse JSON safely\n    try {\n      const obj = JSON.parse(raw);\n      const route = String(obj?.route || \"\").toLowerCase();\n      return route === \"web3\" ? \"web3\" : \"normal\";\n    } catch {\n      // If model returned non-JSON, fallback to normal\n      return \"normal\";\n    }\n  } catch {\n    return \"normal\";\n  } finally {\n    clear();\n  }\n}\n\n/**\n * Low-level gateway call.\n * Always returns: { ok, status, json, text, error }\n * - json is parsed response body (if JSON)\n * - error is a short string for logs/UI\n */\nexport async function aiCall(cfg, path, body, opts = {}) {\n  const base = trimSlash(cfg?.COOKMYBOTS_AI_ENDPOINT || \"\");\n  const key = String(cfg?.COOKMYBOTS_AI_KEY || \"\");\n  const DEBUG = String(cfg?.AI_DEBUG || \"\") === \"1\";\n\n  if (!base || !key) return notConfigured(\"AI_NOT_CONFIGURED (missing COOKMYBOTS_AI_ENDPOINT/COOKMYBOTS_AI_KEY)\");\n\n  const timeoutMs = Number(opts.timeoutMs || pickTimeout(cfg));\n  const retries = Number.isFinite(opts.retries) ? Number(opts.retries) : 1; // default 1 retry\n  const backoffMs = Number.isFinite(opts.backoffMs) ? Number(opts.backoffMs) : 750;\n\n  const url = base + String(path || \"\");\n  const started = Date.now();\n\n  let attempt = 0;\n  while (true) {\n    attempt++;\n\n    const { ctrl, clear } = withTimeout(timeoutMs);\n    try {\n      if (DEBUG) console.log(\"[aiCall] ->\", url, { attempt, timeoutMs });\n\n      const r = await fetch(url, {\n        method: \"POST\",\n        headers: {\n          Authorization: \"Bearer \" + key,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(body || {}),\n        signal: ctrl.signal,\n      });\n\n      const { text, json } = await safeRead(r);\n\n      if (!r.ok) {\n        const err = json?.error || json?.message || text || \"AI_ERROR\";\n        const out = { ok: false, status: r.status, json, text, error: String(err) };\n\n        if (DEBUG) {\n          const ms = Date.now() - started;\n          console.warn(\"[aiCall] <- fail\", { status: r.status, ms, attempt, err: redact(err) });\n        }\n\n        // Retry transient errors\n        if (attempt <= retries && isRetryableStatus(r.status)) {\n          await sleep(backoffMs * attempt);\n          continue;\n        }\n\n        return out;\n      }\n\n      if (DEBUG) {\n        const ms = Date.now() - started;\n        console.log(\"[aiCall] <- ok\", { status: r.status, ms, attempt });\n      }\n\n      return { ok: true, status: r.status, json, text, error: null };\n    } catch (e) {\n      const msg = e?.name === \"AbortError\" ? \"AI_TIMEOUT\" : (e?.message || \"AI_NETWORK_ERROR\");\n      const out = { ok: false, status: e?.name === \"AbortError\" ? 408 : 0, json: null, text: \"\", error: String(msg) };\n\n      if (DEBUG) {\n        const ms = Date.now() - started;\n        console.warn(\"[aiCall] <- exception\", { ms, attempt, err: redact(msg) });\n      }\n\n      // Retry network/timeout issues (status 0/408)\n      if (attempt <= retries) {\n        await sleep(backoffMs * attempt);\n        continue;\n      }\n\n      return out;\n    } finally {\n      clear();\n    }\n  }\n}\n\n/**\n * CHAT\n * Backward compatible:\n * 1) aiChat(cfg, \"hello\", { model, meta, system })\n * 2) aiChat(cfg, { messages:[...], model, meta })\n *\n * Returns: { ok, status, json, text, error }\n */\nexport async function aiChat(cfg, input, opts = {}) {\n  // Signature (cfg, { messages, model, meta })\n  if (input && typeof input === \"object\" && Array.isArray(input.messages)) {\n    const model = pickModel(cfg, input.model);\n    return aiCall(cfg, \"/chat\", {\n      messages: input.messages,\n      model,\n      meta: input.meta || undefined,\n    }, opts);\n  }\n\n  // Signature (cfg, \"prompt\")\n  const userText = String(input || \"\");\n  const system = String(opts.system || \"You are a helpful assistant.\");\n  const model = pickModel(cfg, opts.model);\n\n  return aiCall(cfg, \"/chat\", {\n    messages: [\n      { role: \"system\", content: system },\n      { role: \"user\", content: userText },\n    ],\n    model,\n    meta: opts.meta || undefined,\n  }, opts);\n}\n\n// IMAGE\nexport async function aiImage(cfg, { prompt, size = \"1024x1024\", n = 1, model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/image\", { prompt, size, n, model: m, meta: meta || undefined }, opts);\n}\n\n// VISION\nexport async function aiVision(cfg, { prompt, imageUrl, model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/vision\", { prompt, imageUrl, model: m, meta: meta || undefined }, opts);\n}\n\n// EMBEDDINGS\nexport async function aiEmbeddings(cfg, { input, model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/embeddings\", { input, model: m, meta: meta || undefined }, opts);\n}\n\n// WEB SEARCH\nexport async function aiWebSearch(cfg, { query, meta } = {}, opts = {}) {\n  return aiCall(cfg, \"/web-search\", { query, meta: meta || undefined }, opts);\n}\n\n// SPEECH\nexport async function aiSpeechTts(cfg, { text, voice = \"alloy\", format = \"mp3\", model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/speech/tts\", { text, voice, format, model: m, meta: meta || undefined }, opts);\n}\n\nexport async function aiSpeechStt(cfg, { audioBase64, mimeType = \"audio/mpeg\", filename = \"audio.mp3\", durationSeconds = 0, model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/speech/stt\", { audioBase64, mimeType, filename, durationSeconds, model: m, meta: meta || undefined }, opts);\n}\n\n// VIDEO\nexport async function aiVideoCreate(cfg, { prompt, seconds = 4, size = \"1024x576\", model = \"\", meta } = {}, opts = {}) {\n  const m = pickModel(cfg, model);\n  return aiCall(cfg, \"/video/create\", { prompt, seconds, size, model: m, meta: meta || undefined }, opts);\n}\n\n/**\n * Video status is GET in many gateways.\n * If your gateway is POST-only, you can keep it as GET via fetch() here.\n */\nexport async function aiVideoStatus(cfg, jobId, opts = {}) {\n  const base = trimSlash(cfg?.COOKMYBOTS_AI_ENDPOINT || \"\");\n  const key = String(cfg?.COOKMYBOTS_AI_KEY || \"\");\n  const DEBUG = String(cfg?.AI_DEBUG || \"\") === \"1\";\n\n  if (!base || !key) return notConfigured(\"AI_NOT_CONFIGURED (missing COOKMYBOTS_AI_ENDPOINT/COOKMYBOTS_AI_KEY)\");\n\n  const timeoutMs = Number(opts.timeoutMs || pickTimeout(cfg));\n  const url = base + \"/video/\" + encodeURIComponent(String(jobId || \"\"));\n\n  const { ctrl, clear } = withTimeout(timeoutMs);\n  try {\n    if (DEBUG) console.log(\"[aiVideoStatus] ->\", url);\n\n    const r = await fetch(url, {\n      headers: { Authorization: \"Bearer \" + key },\n      signal: ctrl.signal,\n    });\n\n    const { text, json } = await safeRead(r);\n\n    if (!r.ok) {\n      const err = json?.error || json?.message || text || \"AI_VIDEO_STATUS_ERROR\";\n      if (DEBUG) console.warn(\"[aiVideoStatus] failed:\", r.status, redact(err));\n      return { ok: false, status: r.status, json, text, error: String(err) };\n    }\n\n    return { ok: true, status: r.status, json, text, error: null };\n  } catch (e) {\n    const msg = e?.name === \"AbortError\" ? \"AI_TIMEOUT\" : (e?.message || \"AI_NETWORK_ERROR\");\n    if (DEBUG) console.warn(\"[aiVideoStatus] exception:\", redact(msg));\n    return { ok: false, status: e?.name === \"AbortError\" ? 408 : 0, json: null, text: \"\", error: String(msg) };\n  } finally {\n    clear();\n  }\n}\n\nexport async function aiChainGptChat(cfg, { mode = \"web3\", question, meta } = {}, opts = {}) {\n  const m = web3Mode(cfg);\n  if (m === \"off\") return notConfigured(\"WEB3_DISABLED (WEB3_CHAT_MODE=off)\");\n\n  // mode: \"web3\" | \"smart_contract_generator\" | \"smart_contract_auditor\"\n  return aiCall(cfg, \"/chaingpt/chat\", {\n    mode: String(mode || \"web3\"),\n    question: String(question || \"\"),\n    meta: meta || undefined,\n  }, opts);\n}\n\nexport async function aiChainGptNews(cfg, { limit = 5 } = {}, opts = {}) {\n  const m = web3Mode(cfg);\n  if (m === \"off\") return notConfigured(\"WEB3_DISABLED (WEB3_CHAT_MODE=off)\");\n  const q = Number(limit || 5);\n  const lim = Number.isFinite(q) ? Math.max(1, Math.min(q, 20)) : 5;\n  return aiGet(cfg, \"/chaingpt/news?limit=\" + encodeURIComponent(String(lim)), opts);\n}\n\nexport async function aiChainGptNftImage(cfg, { prompt, model = \"velogen\", steps = 2, width = 512, height = 512, enhance = \"1x\", meta } = {}, opts = {}) {\n  const m = web3Mode(cfg);\n  if (m === \"off\") return notConfigured(\"WEB3_DISABLED (WEB3_CHAT_MODE=off)\");\n\n  return aiCall(cfg, \"/chaingpt/nft/image\", {\n    prompt: String(prompt || \"\"),\n    model: String(model || \"velogen\"),\n    steps: Number(steps || 2),\n    width: Number(width || 512),\n    height: Number(height || 512),\n    enhance: String(enhance || \"1x\"),\n    meta: meta || undefined,\n  }, opts);\n}\n\n// Convenience: auto-route to ChainGPT if it looks web3, else normal aiChat()\nexport async function aiSmartChat(cfg, userText, { system = \"\", meta = {}, retries = 1 } = {}) {\n  const m = web3Mode(cfg);\n\n  // Forced modes\n  if (m === \"on\") {\n    return aiChainGptChat(cfg, { mode: \"web3\", question: String(userText || \"\"), meta }, { retries });\n  }\n  if (m === \"off\") {\n    return aiChat(cfg, String(userText || \"\"), { system: system || \"You are a helpful assistant.\", meta, retries });\n  }\n\n  // AUTO mode: AI decides route\n  const route = await routeChat(cfg, userText, system);\n\n  if (route === \"web3\") {\n    return aiChainGptChat(cfg, { mode: \"web3\", question: String(userText || \"\"), meta }, { retries });\n  }\n\n  return aiChat(cfg, String(userText || \"\"), { system: system || \"You are a helpful assistant.\", meta, retries });\n}\n\n"
                },
                "botProfile.js": {
                  "type": "file",
                  "content": "export function buildBotProfile() {\n  return [\n    \"Purpose: Crypto price lookup, personal watchlists, and polling-based price alerts with Telegram notifications.\",\n    \"Commands:\",\n    \"1) /start - Welcome + buttons for common actions\",\n    \"2) /help - Command list and examples\",\n    \"3) /price <symbol> - Current USD price and 24h change (e.g., /price BTC)\",\n    \"4) /watchlist - List watchlist\",\n    \"5) /watchlist add <symbol> - Add to watchlist\",\n    \"6) /watchlist remove <symbol> - Remove from watchlist\",\n    \"7) /alerts - List alerts\",\n    \"8) /alert add <symbol> above <price> - Create alert\",\n    \"9) /alert add <symbol> below <price> - Create alert\",\n    \"10) /alert remove <alertId> - Remove alert\",\n    \"Rules:\",\n    \"1) Alerts are polling-based so notifications can be delayed by the polling interval.\",\n    \"2) If market data is unavailable, replies use a consistent fallback message.\",\n  ].join(\"\\n\");\n}\n"
                },
                "config.js": {
                  "type": "file",
                  "content": "export const cfg = {\n  TELEGRAM_BOT_TOKEN: process.env.TELEGRAM_BOT_TOKEN,\n  MONGODB_URI: process.env.MONGODB_URI || \"\",\n\n  COIN_API_BASE_URL: process.env.COIN_API_BASE_URL || \"https://api.coingecko.com/api/v3\",\n\n  CACHE_TTL_MS: Number(process.env.CACHE_TTL_MS || 30_000),\n  POLL_INTERVAL_MS: Number(process.env.POLL_INTERVAL_MS || 45_000),\n\n  LOG_LEVEL: process.env.LOG_LEVEL || \"info\",\n};\n"
                },
                "db.js": {
                  "type": "file",
                  "content": "import { MongoClient } from \"mongodb\";\nimport { safeErr } from \"./log.js\";\n\nlet _client = null;\nlet _db = null;\nlet _initPromise = null;\n\nexport async function getDb(mongoUri, log) {\n  if (!mongoUri) return null;\n  if (_db) return _db;\n  if (_initPromise) return _initPromise;\n\n  _initPromise = (async () => {\n    try {\n      _client = new MongoClient(mongoUri, {\n        maxPoolSize: 5,\n        ignoreUndefined: true,\n      });\n      await _client.connect();\n      _db = _client.db();\n\n      if (log) log.info(\"db connected\", { mongo: true });\n\n      await ensureIndexes(_db, log);\n      return _db;\n    } catch (e) {\n      if (log) log.error(\"db connect failed\", { err: safeErr(e) });\n      _client = null;\n      _db = null;\n      _initPromise = null;\n      return null;\n    }\n  })();\n\n  return _initPromise;\n}\n\nasync function ensureIndexes(db, log) {\n  try {\n    await db.collection(\"users\").createIndex({ telegramUserId: 1 }, { unique: true });\n    await db.collection(\"watchlists\").createIndex({ telegramUserId: 1 }, { unique: true });\n    await db.collection(\"alerts\").createIndex({ telegramUserId: 1, status: 1 });\n    await db.collection(\"alerts\").createIndex({ status: 1, symbol: 1 });\n  } catch (e) {\n    if (log) log.error(\"db ensureIndexes failed\", { err: safeErr(e) });\n  }\n}\n\nexport async function closeDb(log) {\n  try {\n    if (_client) await _client.close();\n  } catch (e) {\n    if (log) log.warn(\"db close failed\", { err: safeErr(e) });\n  } finally {\n    _client = null;\n    _db = null;\n    _initPromise = null;\n  }\n}\n"
                },
                "format.js": {
                  "type": "file",
                  "content": "export function fmtUsd(n) {\n  if (typeof n !== \"number\" || !Number.isFinite(n)) return \"N/A\";\n  const abs = Math.abs(n);\n  const digits = abs >= 1000 ? 2 : abs >= 1 ? 4 : 6;\n  return n.toLocaleString(\"en-US\", {\n    style: \"currency\",\n    currency: \"USD\",\n    maximumFractionDigits: digits,\n  });\n}\n\nexport function fmtPct(n) {\n  if (typeof n !== \"number\" || !Number.isFinite(n)) return \"N/A\";\n  const sign = n > 0 ? \"+\" : n < 0 ? \"-\" : \"\";\n  return `${sign}${Math.abs(n).toFixed(2)}%`;\n}\n\nexport function shortId(hex) {\n  const s = String(hex || \"\");\n  return s.length <= 8 ? s : s.slice(0, 8);\n}\n"
                },
                "log.js": {
                  "type": "file",
                  "content": "export function safeErr(err) {\n  return (\n    err?.response?.data?.error?.message ||\n    err?.response?.data?.message ||\n    err?.message ||\n    String(err)\n  );\n}\n\nfunction levelRank(lvl) {\n  const v = String(lvl || \"info\").toLowerCase();\n  if (v === \"debug\") return 10;\n  if (v === \"info\") return 20;\n  if (v === \"warn\") return 30;\n  if (v === \"error\") return 40;\n  return 20;\n}\n\nexport function createLogger({ level = \"info\" } = {}) {\n  const min = levelRank(level);\n  const log = (lvl, msg, meta) => {\n    if (levelRank(lvl) < min) return;\n    const line = {\n      ts: new Date().toISOString(),\n      level: lvl,\n      msg,\n      ...(meta && typeof meta === \"object\" ? meta : {}),\n    };\n    const s = JSON.stringify(line);\n    if (lvl === \"error\") console.error(s);\n    else if (lvl === \"warn\") console.warn(s);\n    else console.log(s);\n  };\n\n  return {\n    debug: (msg, meta) => log(\"debug\", msg, meta),\n    info: (msg, meta) => log(\"info\", msg, meta),\n    warn: (msg, meta) => log(\"warn\", msg, meta),\n    error: (msg, meta) => log(\"error\", msg, meta),\n  };\n}\n"
                },
                "memory.js": {
                  "type": "file",
                  "content": "\n      import { getDb } from \"./db.js\";\n\nconst COL = \"memory_messages\";\n\nexport async function addTurn({ mongoUri, platform, userId, chatId, role, text }) {\n  const db = await getDb(mongoUri);\n  const doc = {\n    platform,\n    userId: String(userId),\n    chatId: chatId ? String(chatId) : \"\",\n    role,\n    text: String(text || \"\").slice(0, 4000),\n    ts: new Date(),\n  };\n\n  if (!db) return; // allow bot to run without DB\n  await db.collection(COL).insertOne(doc);\n}\n\nexport async function getRecentTurns({ mongoUri, platform, userId, chatId, limit = 14 }) {\n  const db = await getDb(mongoUri);\n  if (!db) return [];\n\n  const q = {\n    platform,\n    userId: String(userId),\n  };\n  if (chatId) q.chatId = String(chatId);\n\n  const rows = await db\n    .collection(COL)\n    .find(q)\n    .sort({ ts: -1 })\n    .limit(limit)\n    .toArray();\n\n  // return chronological\n  return rows.reverse().map((r) => ({ role: r.role, text: r.text }));\n}\n\nexport async function clearUserMemory({ mongoUri, platform, userId, chatId }) {\n  const db = await getDb(mongoUri);\n  if (!db) return;\n\n  const q = { platform, userId: String(userId) };\n  if (chatId) q.chatId = String(chatId);\n\n  await db.collection(COL).deleteMany(q);\n}"
                }
              }
            },
            "services": {
              "type": "dir",
              "children": {
                "alerts.js": {
                  "type": "file",
                  "content": "import { ObjectId } from \"mongodb\";\nimport { getDb } from \"../lib/db.js\";\nimport { safeErr } from \"../lib/log.js\";\n\nexport function normalizeDirection(d) {\n  const v = String(d || \"\").trim().toLowerCase();\n  if (v === \"above\" || v === \"up\" || v === \"over\") return \"above\";\n  if (v === \"below\" || v === \"down\" || v === \"under\") return \"below\";\n  return null;\n}\n\nexport function parseTargetPrice(s) {\n  const v = Number(String(s || \"\").replace(/,/g, \"\").trim());\n  if (!Number.isFinite(v) || v <= 0) return null;\n  return v;\n}\n\nexport async function createAlert({ mongoUri, log, telegramUserId, symbol, direction, target }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  const sym = String(symbol || \"\").trim().toUpperCase();\n  const dir = normalizeDirection(direction);\n  const tgt = typeof target === \"number\" ? target : parseTargetPrice(target);\n\n  if (!sym || !dir || !Number.isFinite(tgt)) return { ok: false, reason: \"bad_input\" };\n\n  const doc = {\n    telegramUserId: String(telegramUserId),\n    symbol: sym,\n    direction: dir,\n    target: tgt,\n    status: \"active\",\n    triggeredAt: null,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  };\n\n  try {\n    const r = await db.collection(\"alerts\").insertOne(doc);\n    return { ok: true, id: String(r.insertedId) };\n  } catch (e) {\n    log?.error(\"db alerts create failed\", { op: \"insertOne\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n\nexport async function listAlerts({ mongoUri, log, telegramUserId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\", alerts: [] };\n\n  try {\n    const rows = await db\n      .collection(\"alerts\")\n      .find({ telegramUserId: String(telegramUserId) })\n      .sort({ createdAt: -1 })\n      .limit(100)\n      .toArray();\n\n    return {\n      ok: true,\n      alerts: rows.map((a) => ({\n        id: String(a._id),\n        symbol: String(a.symbol || \"\").toUpperCase(),\n        direction: a.direction === \"below\" ? \"below\" : \"above\",\n        target: Number(a.target),\n        status: a.status === \"triggered\" ? \"triggered\" : \"active\",\n        createdAt: a.createdAt ? new Date(a.createdAt) : null,\n        triggeredAt: a.triggeredAt ? new Date(a.triggeredAt) : null,\n      })),\n    };\n  } catch (e) {\n    log?.error(\"db alerts list failed\", { op: \"find\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\", alerts: [] };\n  }\n}\n\nexport async function removeAlert({ mongoUri, log, telegramUserId, alertId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  try {\n    const _id = new ObjectId(String(alertId));\n    const r = await db.collection(\"alerts\").deleteOne({ _id, telegramUserId: String(telegramUserId) });\n    return { ok: true, removed: r.deletedCount || 0 };\n  } catch (e) {\n    log?.warn(\"db alerts remove failed\", { op: \"deleteOne\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"bad_id\" };\n  }\n}\n\nexport async function clearAlerts({ mongoUri, log, telegramUserId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  try {\n    const r = await db.collection(\"alerts\").deleteMany({ telegramUserId: String(telegramUserId) });\n    return { ok: true, removed: r.deletedCount || 0 };\n  } catch (e) {\n    log?.error(\"db alerts clear failed\", { op: \"deleteMany\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n\nexport async function loadActiveAlerts({ mongoUri, log }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\", alerts: [] };\n\n  try {\n    const rows = await db\n      .collection(\"alerts\")\n      .find({ status: \"active\" })\n      .sort({ createdAt: 1 })\n      .limit(5000)\n      .toArray();\n\n    return {\n      ok: true,\n      alerts: rows.map((a) => ({\n        id: String(a._id),\n        telegramUserId: String(a.telegramUserId),\n        symbol: String(a.symbol || \"\").toUpperCase(),\n        direction: a.direction === \"below\" ? \"below\" : \"above\",\n        target: Number(a.target),\n      })),\n    };\n  } catch (e) {\n    log?.error(\"db alerts loadActive failed\", { op: \"find\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\", alerts: [] };\n  }\n}\n\nexport async function markTriggered({ mongoUri, log, alertId, currentPrice }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  try {\n    const _id = new ObjectId(String(alertId));\n    await db.collection(\"alerts\").updateOne(\n      { _id, status: \"active\" },\n      {\n        $set: {\n          status: \"triggered\",\n          triggeredAt: new Date(),\n          updatedAt: new Date(),\n          lastKnownPrice: Number.isFinite(currentPrice) ? currentPrice : null,\n        },\n      }\n    );\n    return { ok: true };\n  } catch (e) {\n    log?.error(\"db alerts markTriggered failed\", { op: \"updateOne\", col: \"alerts\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n"
                },
                "marketData.js": {
                  "type": "file",
                  "content": "import { safeErr } from \"../lib/log.js\";\n\nfunction sleep(ms) {\n  return new Promise((r) => setTimeout(r, ms));\n}\n\nfunction normalizeSymbol(symbol) {\n  return String(symbol || \"\").trim().toUpperCase();\n}\n\nconst DEFAULT_SYMBOL_MAP = {\n  BTC: { id: \"bitcoin\", name: \"Bitcoin\" },\n  ETH: { id: \"ethereum\", name: \"Ethereum\" },\n  SOL: { id: \"solana\", name: \"Solana\" },\n  BNB: { id: \"binancecoin\", name: \"BNB\" },\n  XRP: { id: \"ripple\", name: \"XRP\" },\n  ADA: { id: \"cardano\", name: \"Cardano\" },\n  DOGE: { id: \"dogecoin\", name: \"Dogecoin\" },\n  TRX: { id: \"tron\", name: \"TRON\" },\n  TON: { id: \"the-open-network\", name: \"Toncoin\" },\n  AVAX: { id: \"avalanche-2\", name: \"Avalanche\" },\n  DOT: { id: \"polkadot\", name: \"Polkadot\" },\n  LINK: { id: \"chainlink\", name: \"Chainlink\" },\n  MATIC: { id: \"matic-network\", name: \"Polygon\" },\n  POL: { id: \"matic-network\", name: \"Polygon\" },\n  SHIB: { id: \"shiba-inu\", name: \"Shiba Inu\" },\n  LTC: { id: \"litecoin\", name: \"Litecoin\" },\n  BCH: { id: \"bitcoin-cash\", name: \"Bitcoin Cash\" },\n  UNI: { id: \"uniswap\", name: \"Uniswap\" },\n  ATOM: { id: \"cosmos\", name: \"Cosmos\" },\n  NEAR: { id: \"near\", name: \"NEAR\" },\n};\n\nexport class MarketDataService {\n  constructor({ baseUrl, cacheTtlMs, log }) {\n    this.baseUrl = String(baseUrl || \"https://api.coingecko.com/api/v3\").replace(/\\/+$/, \"\");\n    this.cacheTtlMs = Number.isFinite(cacheTtlMs) && cacheTtlMs > 0 ? cacheTtlMs : 30_000;\n    this.log = log;\n\n    this.priceCache = new Map();\n    this.inflight = new Map();\n\n    this.symbolMap = new Map(Object.entries(DEFAULT_SYMBOL_MAP).map(([sym, v]) => [sym, v]));\n    this.symbolMapFetchedAt = 0;\n  }\n\n  async getQuoteBySymbol(symbol, { allowStale = true } = {}) {\n    const sym = normalizeSymbol(symbol);\n    if (!sym) return { ok: false, reason: \"missing_symbol\" };\n\n    const mapping = await this.resolveSymbol(sym);\n    if (!mapping) return { ok: false, reason: \"unknown_symbol\", symbol: sym };\n\n    return this.getQuoteByCoinId(mapping.id, { symbol: sym, name: mapping.name, allowStale });\n  }\n\n  async resolveSymbol(sym) {\n    const known = this.symbolMap.get(sym);\n    if (known) return known;\n\n    await this.refreshSymbolMapIfNeeded();\n    return this.symbolMap.get(sym) || null;\n  }\n\n  async refreshSymbolMapIfNeeded() {\n    const now = Date.now();\n    const maxAge = 6 * 60 * 60 * 1000;\n    if (this.symbolMapFetchedAt && now - this.symbolMapFetchedAt < maxAge) return;\n\n    const url = `${this.baseUrl}/coins/list?include_platform=false`;\n    this.log?.info(\"market symbol map fetch start\", { urlHost: safeHost(this.baseUrl) });\n\n    try {\n      const r = await fetch(url, { headers: { \"accept\": \"application/json\" }, signal: AbortSignal.timeout(10_000) });\n      if (!r.ok) throw new Error(`HTTP_${r.status}`);\n      const rows = await r.json();\n      if (!Array.isArray(rows)) throw new Error(\"BAD_RESPONSE\");\n\n      const next = new Map(this.symbolMap);\n      for (const row of rows) {\n        const s = String(row?.symbol || \"\").trim().toUpperCase();\n        const id = String(row?.id || \"\").trim();\n        const name = String(row?.name || \"\").trim();\n        if (!s || !id) continue;\n        if (!next.has(s)) next.set(s, { id, name: name || s });\n      }\n\n      this.symbolMap = next;\n      this.symbolMapFetchedAt = now;\n      this.log?.info(\"market symbol map fetch ok\", { symbols: this.symbolMap.size });\n    } catch (e) {\n      this.log?.warn(\"market symbol map fetch failed\", { err: safeErr(e) });\n      this.symbolMapFetchedAt = now;\n    }\n  }\n\n  async getQuoteByCoinId(coinId, { symbol, name, allowStale }) {\n    const key = `cg:${coinId}:usd`;\n    const now = Date.now();\n    const cached = this.priceCache.get(key);\n\n    if (cached && cached.expiresAt > now) {\n      return { ok: true, ...cached.value, source: \"cache\", stale: false };\n    }\n\n    if (this.inflight.has(key)) {\n      try {\n        const v = await this.inflight.get(key);\n        return v;\n      } catch {\n        // fall through\n      }\n    }\n\n    const p = this._fetchCoinGeckoQuote(coinId, { symbol, name, allowStale, cached });\n    this.inflight.set(key, p);\n    try {\n      return await p;\n    } finally {\n      this.inflight.delete(key);\n    }\n  }\n\n  async _fetchCoinGeckoQuote(coinId, { symbol, name, allowStale, cached }) {\n    const url = `${this.baseUrl}/simple/price?ids=${encodeURIComponent(String(coinId))}&vs_currencies=usd&include_24hr_change=true`;\n\n    this.log?.info(\"market quote fetch start\", { coinId, symbol, urlHost: safeHost(this.baseUrl) });\n\n    try {\n      const started = Date.now();\n      const r = await fetch(url, { headers: { \"accept\": \"application/json\" }, signal: AbortSignal.timeout(10_000) });\n      const ms = Date.now() - started;\n\n      if (!r.ok) throw new Error(`HTTP_${r.status}`);\n      const json = await r.json();\n\n      const row = json?.[coinId];\n      const price = Number(row?.usd);\n      const change = Number(row?.usd_24h_change);\n\n      if (!Number.isFinite(price)) throw new Error(\"BAD_PRICE\");\n\n      const value = {\n        coinId,\n        name: String(name || \"\") || null,\n        symbol: String(symbol || \"\") || null,\n        priceUsd: price,\n        change24hPct: Number.isFinite(change) ? change : null,\n        ts: new Date(),\n      };\n\n      this.priceCache.set(`cg:${coinId}:usd`, {\n        value,\n        expiresAt: Date.now() + this.cacheTtlMs,\n        fetchedAt: Date.now(),\n      });\n\n      this.log?.info(\"market quote fetch ok\", { coinId, symbol, ms });\n      return { ok: true, ...value, source: \"api\", stale: false };\n    } catch (e) {\n      const errMsg = safeErr(e);\n      this.log?.warn(\"market quote fetch failed\", { coinId, symbol, err: errMsg });\n\n      if (allowStale && cached?.value) {\n        const ageMs = Date.now() - (cached.fetchedAt || 0);\n        return { ok: true, ...cached.value, source: \"cache\", stale: true, staleAgeMs: ageMs };\n      }\n\n      return { ok: false, reason: \"api_down\", coinId, symbol };\n    }\n  }\n\n  async getQuotesForSymbols(symbols) {\n    const out = new Map();\n    const unique = [...new Set((symbols || []).map(normalizeSymbol).filter(Boolean))];\n\n    for (const sym of unique) {\n      const r = await this.getQuoteBySymbol(sym, { allowStale: true });\n      out.set(sym, r);\n      await sleep(0);\n    }\n    return out;\n  }\n}\n\nfunction safeHost(baseUrl) {\n  try {\n    const u = new URL(String(baseUrl));\n    return u.host;\n  } catch {\n    return \"\";\n  }\n}\n"
                },
                "users.js": {
                  "type": "file",
                  "content": "import { getDb } from \"../lib/db.js\";\nimport { safeErr } from \"../lib/log.js\";\n\nexport async function upsertUser({ mongoUri, log, telegramUserId, chatId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  try {\n    await db.collection(\"users\").updateOne(\n      { telegramUserId: String(telegramUserId) },\n      {\n        $setOnInsert: { createdAt: new Date() },\n        $set: {\n          telegramUserId: String(telegramUserId),\n          chatId: chatId ? String(chatId) : \"\",\n          updatedAt: new Date(),\n        },\n      },\n      { upsert: true }\n    );\n    return { ok: true };\n  } catch (e) {\n    log?.error(\"db users upsert failed\", { op: \"updateOne\", col: \"users\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n"
                },
                "watchlists.js": {
                  "type": "file",
                  "content": "import { getDb } from \"../lib/db.js\";\nimport { safeErr } from \"../lib/log.js\";\n\nexport async function getWatchlist({ mongoUri, log, telegramUserId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\", symbols: [] };\n\n  try {\n    const doc = await db.collection(\"watchlists\").findOne({ telegramUserId: String(telegramUserId) });\n    const symbols = Array.isArray(doc?.symbols) ? doc.symbols.map((s) => String(s).toUpperCase()) : [];\n    return { ok: true, symbols };\n  } catch (e) {\n    log?.error(\"db watchlists get failed\", { op: \"findOne\", col: \"watchlists\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\", symbols: [] };\n  }\n}\n\nexport async function hasInWatchlist({ mongoUri, log, telegramUserId, symbol }) {\n  const r = await getWatchlist({ mongoUri, log, telegramUserId });\n  if (!r.ok) return { ok: false, has: false };\n  const sym = String(symbol || \"\").trim().toUpperCase();\n  return { ok: true, has: r.symbols.includes(sym) };\n}\n\nexport async function addToWatchlist({ mongoUri, log, telegramUserId, symbol }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  const sym = String(symbol || \"\").trim().toUpperCase();\n  if (!sym) return { ok: false, reason: \"bad_symbol\" };\n\n  try {\n    await db.collection(\"watchlists\").updateOne(\n      { telegramUserId: String(telegramUserId) },\n      {\n        $setOnInsert: { createdAt: new Date() },\n        $set: { updatedAt: new Date() },\n        $addToSet: { symbols: sym },\n      },\n      { upsert: true }\n    );\n    return { ok: true };\n  } catch (e) {\n    log?.error(\"db watchlists add failed\", { op: \"updateOne\", col: \"watchlists\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n\nexport async function removeFromWatchlist({ mongoUri, log, telegramUserId, symbol }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  const sym = String(symbol || \"\").trim().toUpperCase();\n  if (!sym) return { ok: false, reason: \"bad_symbol\" };\n\n  try {\n    await db.collection(\"watchlists\").updateOne(\n      { telegramUserId: String(telegramUserId) },\n      {\n        $set: { updatedAt: new Date() },\n        $pull: { symbols: sym },\n      },\n      { upsert: true }\n    );\n    return { ok: true };\n  } catch (e) {\n    log?.error(\"db watchlists remove failed\", { op: \"updateOne\", col: \"watchlists\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n\nexport async function clearWatchlist({ mongoUri, log, telegramUserId }) {\n  const db = await getDb(mongoUri, log);\n  if (!db) return { ok: false, reason: \"no_db\" };\n\n  try {\n    await db.collection(\"watchlists\").updateOne(\n      { telegramUserId: String(telegramUserId) },\n      {\n        $setOnInsert: { },\n        $set: { symbols: [], updatedAt: new Date() },\n      },\n      { upsert: true }\n    );\n    return { ok: true };\n  } catch (e) {\n    log?.error(\"db watchlists clear failed\", { op: \"updateOne\", col: \"watchlists\", err: safeErr(e) });\n    return { ok: false, reason: \"db_error\" };\n  }\n}\n"
                }
              }
            }
          }
        }
      },
      "commands": [
        {
          "command": "/alert",
          "description": "Adds or removes a price alert.",
          "usage": "/alert add BTC above 70000 | /alert add ETH below 2000 | /alert remove <alertId>",
          "examples": [
            "User: /alert add BTC above 70000 → Bot: Alert created: 3f9a12c1",
            "User: /alert remove 65d4b2f3c9a0f0c2f91d8a11 → Bot: Alert removed."
          ],
          "example": "User: /alert add BTC above 70000 → Bot: Alert created: 3f9a12c1",
          "notes": "Alerts trigger once and are kept as history by marking status=triggered."
        },
        {
          "command": "/alerts",
          "description": "Lists your alerts and provides inline remove buttons.",
          "usage": "/alerts",
          "examples": [
            "User: /alerts → Bot: alert list with short ids + remove buttons"
          ],
          "example": "User: /alerts → Bot: alert list with short ids + remove buttons",
          "notes": "Requires MONGODB_URI."
        },
        {
          "command": "/help",
          "description": "Shows all commands with examples and explains polling-based alert behavior.",
          "usage": "/help",
          "examples": [
            "User: /help → Bot: command list + examples"
          ],
          "example": "User: /help → Bot: command list + examples",
          "notes": "Matches the implemented public commands."
        },
        {
          "command": "/price",
          "description": "Fetches current USD price and 24h percent change for a symbol and shows inline actions.",
          "usage": "/price BTC",
          "examples": [
            "User: /price BTC → Bot: price + change + buttons"
          ],
          "example": "User: /price BTC → Bot: price + change + buttons",
          "notes": "If the market API is down, the bot replies with a consistent fallback message (or cached data if available)."
        },
        {
          "command": "/reset",
          "description": "Clears your watchlist and alerts.",
          "usage": "/reset",
          "examples": [
            "User: /reset → Bot: Done. Your watchlist and alerts were cleared."
          ],
          "example": "User: /reset → Bot: Done. Your watchlist and alerts were cleared.",
          "notes": "Requires MONGODB_URI."
        },
        {
          "command": "/start",
          "description": "Welcome message plus inline menu for Price Lookup, Watchlist, Alerts, and Help.",
          "usage": "/start",
          "examples": [
            "User: /start → Bot: Welcome message + buttons"
          ],
          "example": "User: /start → Bot: Welcome message + buttons",
          "notes": "If MONGODB_URI is not set, the bot will mention that watchlists and alerts are disabled."
        },
        {
          "command": "/watchlist",
          "description": "Lists or updates your watchlist.",
          "usage": "/watchlist | /watchlist add BTC | /watchlist remove BTC",
          "examples": [
            "User: /watchlist → Bot: list of symbols + remove buttons",
            "User: /watchlist add ETH → Bot: confirmed + updated list"
          ],
          "example": "User: /watchlist → Bot: list of symbols + remove buttons",
          "notes": "Requires MONGODB_URI."
        }
      ],
      "envVarDocs": [
        {
          "key": "TELEGRAM_BOT_TOKEN",
          "title": "Telegram Bot Token",
          "description": "Required token for the Telegram bot API.",
          "usage": "Used on boot to create the grammY Bot instance.",
          "howToGet": "Create a bot with BotFather on Telegram and copy the token.",
          "example": "123456789:ABCDEF_your_token_here",
          "isSecret": true,
          "required": true
        },
        {
          "key": "MONGODB_URI",
          "title": "MongoDB Connection String",
          "description": "MongoDB connection string used to persist users, watchlists, and alerts.",
          "usage": "If missing, the bot still runs but watchlists and alerts are disabled.",
          "howToGet": "Use MongoDB Atlas or a managed MongoDB provider and copy the connection string.",
          "example": "mongodb+srv://user:pass@cluster.example.mongodb.net/mydb",
          "isSecret": true,
          "required": false
        },
        {
          "key": "COIN_API_BASE_URL",
          "title": "Market Data API Base URL",
          "description": "Base URL for the market data provider (default: CoinGecko v3).",
          "usage": "Used by MarketDataService for price and symbol list requests.",
          "howToGet": "Optional. Leave default unless you are using a proxy/mirror.",
          "example": "https://api.coingecko.com/api/v3",
          "isSecret": false,
          "required": false
        },
        {
          "key": "CACHE_TTL_MS",
          "title": "Price Cache TTL (ms)",
          "description": "How long price results are cached per symbol to reduce API calls.",
          "usage": "Used by MarketDataService for in-memory caching.",
          "howToGet": "Optional tuning parameter.",
          "example": "30000",
          "isSecret": false,
          "required": false
        },
        {
          "key": "POLL_INTERVAL_MS",
          "title": "Alert Polling Interval (ms)",
          "description": "How often the bot checks active alerts and sends notifications when targets are hit.",
          "usage": "Used by the in-process alert poller loop.",
          "howToGet": "Optional tuning parameter.",
          "example": "45000",
          "isSecret": false,
          "required": false
        },
        {
          "key": "LOG_LEVEL",
          "title": "Log Level",
          "description": "Controls logging verbosity.",
          "usage": "Used by src/lib/log.js to filter logs.",
          "howToGet": "Optional tuning parameter.",
          "example": "info",
          "isSecret": false,
          "required": false
        }
      ],
      "commandDocs": [
        {
          "command": "/start",
          "description": "Welcome message plus inline menu for Price Lookup, Watchlist, Alerts, and Help.",
          "usage": "/start",
          "examples": [
            "User: /start → Bot: Welcome message + buttons"
          ],
          "notes": "If MONGODB_URI is not set, the bot will mention that watchlists and alerts are disabled."
        },
        {
          "command": "/help",
          "description": "Shows all commands with examples and explains polling-based alert behavior.",
          "usage": "/help",
          "examples": [
            "User: /help → Bot: command list + examples"
          ],
          "notes": "Matches the implemented public commands."
        },
        {
          "command": "/price",
          "description": "Fetches current USD price and 24h percent change for a symbol and shows inline actions.",
          "usage": "/price BTC",
          "examples": [
            "User: /price BTC → Bot: price + change + buttons"
          ],
          "notes": "If the market API is down, the bot replies with a consistent fallback message (or cached data if available)."
        },
        {
          "command": "/watchlist",
          "description": "Lists or updates your watchlist.",
          "usage": "/watchlist | /watchlist add BTC | /watchlist remove BTC",
          "examples": [
            "User: /watchlist → Bot: list of symbols + remove buttons",
            "User: /watchlist add ETH → Bot: confirmed + updated list"
          ],
          "notes": "Requires MONGODB_URI."
        },
        {
          "command": "/alerts",
          "description": "Lists your alerts and provides inline remove buttons.",
          "usage": "/alerts",
          "examples": [
            "User: /alerts → Bot: alert list with short ids + remove buttons"
          ],
          "notes": "Requires MONGODB_URI."
        },
        {
          "command": "/alert",
          "description": "Adds or removes a price alert.",
          "usage": "/alert add BTC above 70000 | /alert add ETH below 2000 | /alert remove <alertId>",
          "examples": [
            "User: /alert add BTC above 70000 → Bot: Alert created: 3f9a12c1",
            "User: /alert remove 65d4b2f3c9a0f0c2f91d8a11 → Bot: Alert removed."
          ],
          "notes": "Alerts trigger once and are kept as history by marking status=triggered."
        },
        {
          "command": "/reset",
          "description": "Clears your watchlist and alerts.",
          "usage": "/reset",
          "examples": [
            "User: /reset → Bot: Done. Your watchlist and alerts were cleared."
          ],
          "notes": "Requires MONGODB_URI."
        }
      ],
      "aiMessages": [
        {
          "role": "user",
          "content": "Build a Telegram crypto price + alerts bot:\n\n- Watchlist: add/remove coins and list watchlist.\n- Price lookup: /price <symbol> (returns price + 24h change).\n- Alerts: set above/below alerts per coin; list and remove alerts.\n- Notifications: alert users when targets are hit.\n- Reliability: caching, graceful errors, and “API down” fallback message.\n- UX: quick inline buttons for common actions (Add alert, Remove, Watchlist)."
        },
        {
          "role": "assistant",
          "content": "Created a new grammY Telegram bot project for crypto price lookup, watchlists, and polling-based alerts with inline-button UX. Added MongoDB persistence (users/watchlists/alerts), a CoinGecko market data service with caching and stale fallback, an in-process alert poller that groups checks by symbol and triggers notifications once, plus production-safe logging and DOCS/.env.sample.\n\nFiles touched (28): .env.sample, DOCS.md, README.md, package.json, project.json, src/bot.js…\nValidation: ✅ project passes syntax/basic checks after this edit."
        }
      ],
      "createdBy": "",
      "source": "",
      "description": "",
      "planMarkdown": "Bot: Telegram Crypto Price + Alerts Bot (grammY, Node.js ESM) — Production-Ready System Plan\n\nSummary:\nA single-process Telegram bot that lets users look up crypto prices, manage a personal watchlist, and configure above/below price alerts per coin. The bot periodically checks prices from an external market-data API and sends notifications when alert conditions are met.\n\nThe plan emphasizes reliability (caching, rate limiting, graceful degradation when APIs are down), good UX (inline buttons for common actions, clear formatting, and guided flows), and maintainability (clean separation of concerns, MongoDB persistence, idempotent alert triggering, and observable operations).\n\nProduct goals:\nPrimary user goals\n\n1) Fast price lookup: Users can request /price BTC and instantly receive the current price and 24h change.\n2) Personal watchlist: Users can maintain a list of coins they care about and retrieve it quickly.\n3) Price alerts: Users can set alerts like BTC above 70000 or ETH below 3000 and be notified when thresholds are crossed.\n4) Low-friction UX: Inline buttons reduce typing; bot responses include quick next actions (Add alert, Remove, Watchlist).\n\nProduct principles\n\n1) Correctness over completeness: Prefer a smaller set of reliably supported symbols over trying to resolve every ambiguous ticker.\n2) Predictable alerts: Alerts should trigger once per condition hit and avoid spam during volatility.\n3) Transparent reliability: When upstream APIs fail, return a clear fallback message and keep bot responsive.\n4) Minimal user configuration: Default currency (e.g., USD) and sane defaults for alert behavior; allow customization later.\n\nScope boundaries (v1)\n\n1) Not a trading bot; no orders, wallets, or sensitive user keys.\n2) No complex technical indicators; only spot price and 24h change.\n3) Alerts are based on spot price threshold crossing, not candles or time windows.\n\nHigh-level architecture:\nHigh-level architecture (single Node.js process)\n\n1) Telegram interaction layer (grammY)\n   1) Command handlers: /start, /price, /watchlist, /alerts, etc.\n   2) Callback query handlers for inline buttons.\n   3) Input parsing and validation (symbols, prices).\n\n2) Domain services\n   1) MarketDataService: fetches prices and 24h change, normalizes data, handles symbol mapping.\n   2) WatchlistService: add/remove/list watchlist entries.\n   3) AlertsService: create/list/delete alerts; evaluate alerts against prices; manage alert state to prevent duplicate notifications.\n   4) NotificationService: sends messages; handles failures (blocked bot, chat not found) and updates user status.\n\n3) Persistence (MongoDB)\n   1) Users, watchlists, alerts, symbol registry (optional), and operational state needed for alert triggering.\n\n4) Caching and rate control (in-process)\n   1) Short-lived cache for price lookups to reduce API calls (e.g., 10–30 seconds per symbol).\n   2) In-flight request de-duplication per symbol (avoid concurrent fetch storms).\n   3) Global throttling for upstream API calls.\n\n5) Scheduler (in-process loop)\n   1) Periodic alert evaluation job (e.g., every 15–30 seconds; configurable).\n   2) Batching strategy: compute unique symbols needed by active alerts, fetch prices in batches when supported by the provider, then evaluate all alerts.\n\nOperational lifecycle\n\n1) Bot starts, connects to MongoDB, initializes grammY, registers handlers.\n2) Scheduler starts after successful initialization.\n3) Health and readiness checks are exposed internally (for the host environment) and logged.\n\nFailure isolation\n\n1) Upstream API failure must not crash the bot. Errors are caught and turned into:\n   1) User-facing fallback response for /price.\n   2) Skipped alert cycle with backoff for scheduler.\n2) Telegram send failures are handled per message; persistent failures mark user as unreachable to reduce retries.\n\nSymbol resolution strategy\n\n1) Maintain a canonical internal coinId (string) separate from user-entered symbol.\n2) Use a deterministic mapping table for popular symbols (BTC, ETH, SOL, etc.).\n3) When ambiguous (e.g., multiple assets share a symbol), the bot responds with a disambiguation prompt via inline buttons. Store the resolved mapping per user preference to reduce future ambiguity.\n\nData model:\nMongoDB collections (suggested)\n\n1) users\n   1) id: ObjectId\n   2) telegramUserId: number (unique)\n   3) chatId: number (for direct messages; for groups store per chat usage if supported)\n   4) locale: string (optional)\n   5) defaultFiat: string (e.g., USD)\n   6) createdAt, updatedAt\n   7) status:\n      1) active | blocked | unreachable\n      2) lastSendErrorAt, lastSendErrorReason\n\n2) watchlists\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) items: array of\n      1) coinId: string\n      2) symbol: string (display)\n      3) addedAt: date\n   4) updatedAt\n   Notes:\n   1) Alternatively store as separate documents per item for easier indexing; for v1 array is fine if sizes remain small.\n\n3) alerts\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) coinId: string (indexed)\n   4) symbol: string (display)\n   5) direction: above | below\n   6) targetPrice: number\n   7) fiat: string (e.g., USD)\n   8) status: active | triggered | paused\n   9) createdAt, updatedAt\n   10) triggeredAt: date (nullable)\n   11) lastEvaluatedAt: date (optional)\n   12) lastKnownPrice: number (optional)\n   13) triggerPolicy:\n       1) once (default) or repeat\n       2) if repeat: cooldownSeconds\n   Rationale:\n   1) Storing lastKnownPrice enables crossing detection (trigger only when crossing occurs, not merely staying above).\n\n4) coinregistry (optional but recommended)\n   1) coinId: string (unique)\n   2) primarySymbol: string\n   3) name: string\n   4) aliases: array of strings\n   5) providerIdentifiers: object (per market data provider)\n   6) updatedAt\n   Notes:\n   1) Can be curated for top coins and extended later; not mandatory for v1 if provider supports direct symbol query.\n\nIndexes\n\n1) users: unique index on telegramUserId\n2) alerts: compound index on status + coinId (for fast retrieval of active alerts grouped by symbol)\n3) alerts: index on telegramUserId (for list operations)\n4) watchlists: index on telegramUserId\n\nIn-memory structures (non-persistent)\n\n1) priceCache: Map keyed by coinId+fiat with value {price, change24h, fetchedAt, expiresAt}\n2) inflightFetches: Map keyed by coinId+fiat to Promise-like tracking to deduplicate\n3) schedulerState: lastRunAt, consecutiveFailures, backoffUntil\n\nKey flows:\n1) /start onboarding\n\n1) Create or update user record (telegramUserId, chatId).\n2) Send a welcome message with:\n   1) How to use /price\n   2) How to add alerts\n   3) Inline buttons: Price, Watchlist, Alerts\n\n2) Price lookup: /price <symbol>\n\n1) Parse input symbol; normalize (trim, uppercase).\n2) Resolve to coinId:\n   1) If exact match in coin registry, proceed.\n   2) If ambiguous, return a list of options via inline buttons.\n   3) If unknown, return a helpful error and suggest examples.\n3) Fetch market data:\n   1) Check cache (fresh within TTL). If present, use it.\n   2) Else call MarketDataService with retry policy (limited) and timeout.\n4) Reply with formatted result:\n   1) Price in defaultFiat\n   2) 24h change (percentage)\n   3) Last updated timestamp\n   4) Inline buttons: Add alert (above/below), Add to watchlist, View alerts for this coin\n5) If API fails:\n   1) Reply with fallback message: market data temporarily unavailable; suggest trying again.\n   2) Optionally show the last cached value if it exists but is stale, clearly marked as stale.\n\n3) Watchlist management\n\nA) Add: /watchlistadd <symbol> (and inline button Add to watchlist)\n1) Resolve symbol to coinId (same as /price).\n2) Upsert watchlist item; avoid duplicates.\n3) Confirm and show watchlist summary with inline actions.\n\nB) Remove: /watchlistremove <symbol> (and inline button Remove)\n1) Resolve symbol.\n2) Remove if present.\n3) Confirm outcome (removed or not found).\n\nC) List: /watchlist\n1) Load watchlist items.\n2) Optionally fetch current prices for items:\n   1) Batch fetch unique coinIds with caching.\n   2) Show a compact list with price and 24h change.\n3) Provide inline buttons per item: Price, Add alert, Remove.\n\n4) Alerts management\n\nA) Create: /alert <symbol> <above|below> <price>\n1) Parse and validate numeric target price.\n2) Resolve symbol to coinId.\n3) Create alert with status active and default triggerPolicy once.\n4) Reply with confirmation and inline buttons:\n   1) List alerts\n   2) Remove this alert\n   3) View price\n\nB) Guided creation via inline buttons\n1) User taps Add alert from a price message.\n2) Bot prompts:\n   1) Choose direction (above/below) via buttons.\n   2) Enter target price (free text).\n3) Validate and create alert.\n\nC) List: /alerts\n1) Load alerts for user.\n2) Group by coin and show status (active/triggered).\n3) Inline buttons for each alert: Remove, Pause/Resume (optional), View price.\n\nD) Remove: /alertremove <id> or via inline button\n1) Validate ownership (telegramUserId matches).\n2) Delete or mark as deleted.\n3) Confirm.\n\n5) Notification cycle (scheduler)\n\n1) Every interval, load active alerts (status=active).\n2) Determine unique coinIds needed; fetch prices (batch when possible).\n3) For each alert evaluate condition:\n   1) Above: currentPrice >= targetPrice\n   2) Below: currentPrice <= targetPrice\n4) Anti-spam and correctness:\n   1) Default behavior triggers once then marks triggered.\n   2) Optional crossing logic: if lastKnownPrice exists, only trigger when crossing the threshold from the other side.\n   3) Record triggeredAt and status update.\n5) Send notification:\n   1) Message includes coin, current price, target, and quick actions (Remove, Add another alert, View price).\n   2) Handle send errors; if blocked/unreachable, set user status accordingly.\n6) Persist updates (alert status, lastKnownPrice).\n\n6) Resilience and fallback behaviors\n\n1) If market data API is down during /price:\n   1) Respond quickly with a user-friendly error.\n   2) Optionally include stale cached value if available.\n2) If API is down during scheduler:\n   1) Skip evaluation cycle.\n   2) Increase backoff and log the incident.\n3) If MongoDB is temporarily unavailable:\n   1) Commands that require persistence return a degraded-mode message.\n   2) Price lookup may still work using in-memory cache only.\n4) Telegram rate limits:\n   1) NotificationService batches or throttles sends.\n   2) Avoid sending multiple alerts in one second to the same chat; combine messages when many alerts trigger simultaneously.\n\nTech stack:\nRuntime and framework\n\n1) Node.js (ESM) single service/process.\n2) grammY for Telegram bot API integration.\n3) Environment configuration via process environment variables, including TELEGRAMBOTTOKEN.\n\nPersistence\n\n1) MongoDB for durable storage of users, watchlists, and alerts.\n2) In-memory maps for short-lived caching and in-flight request deduplication.\n\nExternal integration\n\n1) One primary market data API provider (HTTP-based) that supports:\n   1) Spot price per coin in a fiat currency\n   2) 24h change\n   3) Optional batch queries\n2) Optional secondary provider as fallback if allowed; otherwise provide a clear API-down message.\n\nStorage\n\n1) No file storage is required for core features.\n2) If later adding charts or snapshots, store generated images in object storage or simple filesystem storage.\n\nDeployment\n\n1) Run as a Node.js server in the cloud.\n2) Use long polling or webhook mode depending on hosting capabilities; both remain within a single process.\n\nOperational tooling (within the same service)\n\n1) Structured logging (request/command context, correlation ids for updates).\n2) Basic internal metrics counters (in-memory) for:\n   1) /price requests\n   2) API successes/failures\n   3) alerts evaluated and triggered\n   4) Telegram send failures\n3) Health endpoints or health logging for readiness/liveness (implementation depends on hosting).\n\nNon-functional requirements:\nReliability\n\n1) Timeouts on all upstream HTTP calls; fail fast.\n2) Retries with jitter for transient failures (bounded, small count).\n3) Cache responses briefly to reduce load and improve latency.\n4) Scheduler backoff on repeated upstream failures.\n\nCorrectness and alert semantics\n\n1) Alerts are idempotent: once triggered, they are marked triggered to prevent repeats.\n2) Optional crossing detection reduces false triggers when an alert is created while already beyond target.\n3) All comparisons use consistent numeric parsing and rounding strategy; display rounding is separate from evaluation precision.\n\nPerformance\n\n1) Batch price fetching for alert evaluation.\n2) Avoid N+1 database calls by preloading active alerts and grouping them.\n3) Keep watchlists small by design; if large lists are allowed later, switch to per-item documents.\n\nSecurity and abuse prevention\n\n1) Input validation for symbols and target prices.\n2) Basic per-user rate limiting in memory to prevent spam (commands per minute).\n3) Do not log sensitive user content beyond what is required for debugging.\n4) Handle group chats carefully (optional in v1). If enabled, store alerts per chatId and ensure admin-only management if desired.\n\nObservability and operations\n\n1) Log all failures with actionable context (provider status, HTTP status, latency).\n2) Track alert trigger outcomes and Telegram send errors.\n3) Provide an admin-only command set for basic diagnostics (counts, last API error, scheduler status).\n\nUX and accessibility\n\n1) Consistent message format with compact numbers and clear timestamps.\n2) Inline buttons for common next steps:\n   1) Add alert above/below\n   2) Add/remove watchlist\n   3) List alerts\n3) Clear error messages with examples.\n\nData retention\n\n1) Keep triggered alerts for a limited time for user visibility, then optionally auto-archive/delete.\n2) Allow users to delete alerts and watchlist items at any time.\n\nTesting strategy (system-level plan)\n\n1) Unit test domain services (symbol resolution, alert evaluation, caching behavior).\n2) Integration test MongoDB operations for alerts and watchlists.\n3) End-to-end test key Telegram flows with simulated updates.\n4) Load test scheduler logic with many alerts to validate batching and rate limiting.\n\nBot commands:\n• /start — Initialize the bot, save your user profile, and show quick help with buttons. (usage: /start) [Onboarding]\n• /help — Show usage instructions and examples for prices, watchlists, and alerts. (usage: /help) [Onboarding]\n• /price — Get current price and 24h change for a symbol, with quick actions to add alerts or watchlist. (usage: /price <symbol>) [Market Data]\n• /watchlist — List your watchlist, optionally including current prices and 24h change, with per-coin actions. (usage: /watchlist) [Watchlist]\n• /watchlistadd — Add a coin to your watchlist. (usage: /watchlistadd <symbol>) [Watchlist]\n• /watchlistremove — Remove a coin from your watchlist. (usage: /watchlistremove <symbol>) [Watchlist]\n• /alerts — List all your alerts with status and quick buttons to remove or view price. (usage: /alerts) [Alerts]\n• /alert — Create a price threshold alert for a coin (above or below). (usage: /alert <symbol> <above|below> <targetPrice>) [Alerts]\n• /alertremove — Remove an alert by its id (or use inline buttons from /alerts). (usage: /alertremove <alertId>) [Alerts]\n• /status — Show basic bot status, including whether market data is currently available (admin-only). (usage: /status) [Admin]\n",
      "planSections": {
        "productGoals": "Primary user goals\n\n1) Fast price lookup: Users can request /price BTC and instantly receive the current price and 24h change.\n2) Personal watchlist: Users can maintain a list of coins they care about and retrieve it quickly.\n3) Price alerts: Users can set alerts like BTC above 70000 or ETH below 3000 and be notified when thresholds are crossed.\n4) Low-friction UX: Inline buttons reduce typing; bot responses include quick next actions (Add alert, Remove, Watchlist).\n\nProduct principles\n\n1) Correctness over completeness: Prefer a smaller set of reliably supported symbols over trying to resolve every ambiguous ticker.\n2) Predictable alerts: Alerts should trigger once per condition hit and avoid spam during volatility.\n3) Transparent reliability: When upstream APIs fail, return a clear fallback message and keep bot responsive.\n4) Minimal user configuration: Default currency (e.g., USD) and sane defaults for alert behavior; allow customization later.\n\nScope boundaries (v1)\n\n1) Not a trading bot; no orders, wallets, or sensitive user keys.\n2) No complex technical indicators; only spot price and 24h change.\n3) Alerts are based on spot price threshold crossing, not candles or time windows.",
        "highLevelArchitecture": "High-level architecture (single Node.js process)\n\n1) Telegram interaction layer (grammY)\n   1) Command handlers: /start, /price, /watchlist, /alerts, etc.\n   2) Callback query handlers for inline buttons.\n   3) Input parsing and validation (symbols, prices).\n\n2) Domain services\n   1) MarketDataService: fetches prices and 24h change, normalizes data, handles symbol mapping.\n   2) WatchlistService: add/remove/list watchlist entries.\n   3) AlertsService: create/list/delete alerts; evaluate alerts against prices; manage alert state to prevent duplicate notifications.\n   4) NotificationService: sends messages; handles failures (blocked bot, chat not found) and updates user status.\n\n3) Persistence (MongoDB)\n   1) Users, watchlists, alerts, symbol registry (optional), and operational state needed for alert triggering.\n\n4) Caching and rate control (in-process)\n   1) Short-lived cache for price lookups to reduce API calls (e.g., 10–30 seconds per symbol).\n   2) In-flight request de-duplication per symbol (avoid concurrent fetch storms).\n   3) Global throttling for upstream API calls.\n\n5) Scheduler (in-process loop)\n   1) Periodic alert evaluation job (e.g., every 15–30 seconds; configurable).\n   2) Batching strategy: compute unique symbols needed by active alerts, fetch prices in batches when supported by the provider, then evaluate all alerts.\n\nOperational lifecycle\n\n1) Bot starts, connects to MongoDB, initializes grammY, registers handlers.\n2) Scheduler starts after successful initialization.\n3) Health and readiness checks are exposed internally (for the host environment) and logged.\n\nFailure isolation\n\n1) Upstream API failure must not crash the bot. Errors are caught and turned into:\n   1) User-facing fallback response for /price.\n   2) Skipped alert cycle with backoff for scheduler.\n2) Telegram send failures are handled per message; persistent failures mark user as unreachable to reduce retries.\n\nSymbol resolution strategy\n\n1) Maintain a canonical internal coinId (string) separate from user-entered symbol.\n2) Use a deterministic mapping table for popular symbols (BTC, ETH, SOL, etc.).\n3) When ambiguous (e.g., multiple assets share a symbol), the bot responds with a disambiguation prompt via inline buttons. Store the resolved mapping per user preference to reduce future ambiguity.",
        "dataModel": "MongoDB collections (suggested)\n\n1) users\n   1) id: ObjectId\n   2) telegramUserId: number (unique)\n   3) chatId: number (for direct messages; for groups store per chat usage if supported)\n   4) locale: string (optional)\n   5) defaultFiat: string (e.g., USD)\n   6) createdAt, updatedAt\n   7) status:\n      1) active | blocked | unreachable\n      2) lastSendErrorAt, lastSendErrorReason\n\n2) watchlists\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) items: array of\n      1) coinId: string\n      2) symbol: string (display)\n      3) addedAt: date\n   4) updatedAt\n   Notes:\n   1) Alternatively store as separate documents per item for easier indexing; for v1 array is fine if sizes remain small.\n\n3) alerts\n   1) id: ObjectId\n   2) telegramUserId: number (indexed)\n   3) coinId: string (indexed)\n   4) symbol: string (display)\n   5) direction: above | below\n   6) targetPrice: number\n   7) fiat: string (e.g., USD)\n   8) status: active | triggered | paused\n   9) createdAt, updatedAt\n   10) triggeredAt: date (nullable)\n   11) lastEvaluatedAt: date (optional)\n   12) lastKnownPrice: number (optional)\n   13) triggerPolicy:\n       1) once (default) or repeat\n       2) if repeat: cooldownSeconds\n   Rationale:\n   1) Storing lastKnownPrice enables crossing detection (trigger only when crossing occurs, not merely staying above).\n\n4) coinregistry (optional but recommended)\n   1) coinId: string (unique)\n   2) primarySymbol: string\n   3) name: string\n   4) aliases: array of strings\n   5) providerIdentifiers: object (per market data provider)\n   6) updatedAt\n   Notes:\n   1) Can be curated for top coins and extended later; not mandatory for v1 if provider supports direct symbol query.\n\nIndexes\n\n1) users: unique index on telegramUserId\n2) alerts: compound index on status + coinId (for fast retrieval of active alerts grouped by symbol)\n3) alerts: index on telegramUserId (for list operations)\n4) watchlists: index on telegramUserId\n\nIn-memory structures (non-persistent)\n\n1) priceCache: Map keyed by coinId+fiat with value {price, change24h, fetchedAt, expiresAt}\n2) inflightFetches: Map keyed by coinId+fiat to Promise-like tracking to deduplicate\n3) schedulerState: lastRunAt, consecutiveFailures, backoffUntil",
        "keyFlows": "1) /start onboarding\n\n1) Create or update user record (telegramUserId, chatId).\n2) Send a welcome message with:\n   1) How to use /price\n   2) How to add alerts\n   3) Inline buttons: Price, Watchlist, Alerts\n\n2) Price lookup: /price <symbol>\n\n1) Parse input symbol; normalize (trim, uppercase).\n2) Resolve to coinId:\n   1) If exact match in coin registry, proceed.\n   2) If ambiguous, return a list of options via inline buttons.\n   3) If unknown, return a helpful error and suggest examples.\n3) Fetch market data:\n   1) Check cache (fresh within TTL). If present, use it.\n   2) Else call MarketDataService with retry policy (limited) and timeout.\n4) Reply with formatted result:\n   1) Price in defaultFiat\n   2) 24h change (percentage)\n   3) Last updated timestamp\n   4) Inline buttons: Add alert (above/below), Add to watchlist, View alerts for this coin\n5) If API fails:\n   1) Reply with fallback message: market data temporarily unavailable; suggest trying again.\n   2) Optionally show the last cached value if it exists but is stale, clearly marked as stale.\n\n3) Watchlist management\n\nA) Add: /watchlistadd <symbol> (and inline button Add to watchlist)\n1) Resolve symbol to coinId (same as /price).\n2) Upsert watchlist item; avoid duplicates.\n3) Confirm and show watchlist summary with inline actions.\n\nB) Remove: /watchlistremove <symbol> (and inline button Remove)\n1) Resolve symbol.\n2) Remove if present.\n3) Confirm outcome (removed or not found).\n\nC) List: /watchlist\n1) Load watchlist items.\n2) Optionally fetch current prices for items:\n   1) Batch fetch unique coinIds with caching.\n   2) Show a compact list with price and 24h change.\n3) Provide inline buttons per item: Price, Add alert, Remove.\n\n4) Alerts management\n\nA) Create: /alert <symbol> <above|below> <price>\n1) Parse and validate numeric target price.\n2) Resolve symbol to coinId.\n3) Create alert with status active and default triggerPolicy once.\n4) Reply with confirmation and inline buttons:\n   1) List alerts\n   2) Remove this alert\n   3) View price\n\nB) Guided creation via inline buttons\n1) User taps Add alert from a price message.\n2) Bot prompts:\n   1) Choose direction (above/below) via buttons.\n   2) Enter target price (free text).\n3) Validate and create alert.\n\nC) List: /alerts\n1) Load alerts for user.\n2) Group by coin and show status (active/triggered).\n3) Inline buttons for each alert: Remove, Pause/Resume (optional), View price.\n\nD) Remove: /alertremove <id> or via inline button\n1) Validate ownership (telegramUserId matches).\n2) Delete or mark as deleted.\n3) Confirm.\n\n5) Notification cycle (scheduler)\n\n1) Every interval, load active alerts (status=active).\n2) Determine unique coinIds needed; fetch prices (batch when possible).\n3) For each alert evaluate condition:\n   1) Above: currentPrice >= targetPrice\n   2) Below: currentPrice <= targetPrice\n4) Anti-spam and correctness:\n   1) Default behavior triggers once then marks triggered.\n   2) Optional crossing logic: if lastKnownPrice exists, only trigger when crossing the threshold from the other side.\n   3) Record triggeredAt and status update.\n5) Send notification:\n   1) Message includes coin, current price, target, and quick actions (Remove, Add another alert, View price).\n   2) Handle send errors; if blocked/unreachable, set user status accordingly.\n6) Persist updates (alert status, lastKnownPrice).\n\n6) Resilience and fallback behaviors\n\n1) If market data API is down during /price:\n   1) Respond quickly with a user-friendly error.\n   2) Optionally include stale cached value if available.\n2) If API is down during scheduler:\n   1) Skip evaluation cycle.\n   2) Increase backoff and log the incident.\n3) If MongoDB is temporarily unavailable:\n   1) Commands that require persistence return a degraded-mode message.\n   2) Price lookup may still work using in-memory cache only.\n4) Telegram rate limits:\n   1) NotificationService batches or throttles sends.\n   2) Avoid sending multiple alerts in one second to the same chat; combine messages when many alerts trigger simultaneously.",
        "techStack": "Runtime and framework\n\n1) Node.js (ESM) single service/process.\n2) grammY for Telegram bot API integration.\n3) Environment configuration via process environment variables, including TELEGRAMBOTTOKEN.\n\nPersistence\n\n1) MongoDB for durable storage of users, watchlists, and alerts.\n2) In-memory maps for short-lived caching and in-flight request deduplication.\n\nExternal integration\n\n1) One primary market data API provider (HTTP-based) that supports:\n   1) Spot price per coin in a fiat currency\n   2) 24h change\n   3) Optional batch queries\n2) Optional secondary provider as fallback if allowed; otherwise provide a clear API-down message.\n\nStorage\n\n1) No file storage is required for core features.\n2) If later adding charts or snapshots, store generated images in object storage or simple filesystem storage.\n\nDeployment\n\n1) Run as a Node.js server in the cloud.\n2) Use long polling or webhook mode depending on hosting capabilities; both remain within a single process.\n\nOperational tooling (within the same service)\n\n1) Structured logging (request/command context, correlation ids for updates).\n2) Basic internal metrics counters (in-memory) for:\n   1) /price requests\n   2) API successes/failures\n   3) alerts evaluated and triggered\n   4) Telegram send failures\n3) Health endpoints or health logging for readiness/liveness (implementation depends on hosting).",
        "nonFunctional": "Reliability\n\n1) Timeouts on all upstream HTTP calls; fail fast.\n2) Retries with jitter for transient failures (bounded, small count).\n3) Cache responses briefly to reduce load and improve latency.\n4) Scheduler backoff on repeated upstream failures.\n\nCorrectness and alert semantics\n\n1) Alerts are idempotent: once triggered, they are marked triggered to prevent repeats.\n2) Optional crossing detection reduces false triggers when an alert is created while already beyond target.\n3) All comparisons use consistent numeric parsing and rounding strategy; display rounding is separate from evaluation precision.\n\nPerformance\n\n1) Batch price fetching for alert evaluation.\n2) Avoid N+1 database calls by preloading active alerts and grouping them.\n3) Keep watchlists small by design; if large lists are allowed later, switch to per-item documents.\n\nSecurity and abuse prevention\n\n1) Input validation for symbols and target prices.\n2) Basic per-user rate limiting in memory to prevent spam (commands per minute).\n3) Do not log sensitive user content beyond what is required for debugging.\n4) Handle group chats carefully (optional in v1). If enabled, store alerts per chatId and ensure admin-only management if desired.\n\nObservability and operations\n\n1) Log all failures with actionable context (provider status, HTTP status, latency).\n2) Track alert trigger outcomes and Telegram send errors.\n3) Provide an admin-only command set for basic diagnostics (counts, last API error, scheduler status).\n\nUX and accessibility\n\n1) Consistent message format with compact numbers and clear timestamps.\n2) Inline buttons for common next steps:\n   1) Add alert above/below\n   2) Add/remove watchlist\n   3) List alerts\n3) Clear error messages with examples.\n\nData retention\n\n1) Keep triggered alerts for a limited time for user visibility, then optionally auto-archive/delete.\n2) Allow users to delete alerts and watchlist items at any time.\n\nTesting strategy (system-level plan)\n\n1) Unit test domain services (symbol resolution, alert evaluation, caching behavior).\n2) Integration test MongoDB operations for alerts and watchlists.\n3) End-to-end test key Telegram flows with simulated updates.\n4) Load test scheduler logic with many alerts to validate batching and rate limiting."
      },
      "balanceCentsRemaining": 1034072,
      "billing": {
        "ok": true,
        "charged": 49,
        "remaining": 1034072,
        "chargedCents": 49,
        "remainingCents": 1034072,
        "currency": "USD",
        "baseUsd": 0.243704,
        "markupUsd": 0.243704,
        "platformFeeUsd": 0,
        "totalUsd": 0.487408
      },
      "title": "Telegram Crypto Price + Aler"
    }
  },
  "envVarDocs": [
    {
      "key": "TELEGRAM_BOT_TOKEN",
      "title": "Telegram Bot Token",
      "description": "Required token for the Telegram bot API.",
      "usage": "Used on boot to create the grammY Bot instance.",
      "howToGet": "Create a bot with BotFather on Telegram and copy the token.",
      "example": "123456789:ABCDEF_your_token_here",
      "isSecret": true,
      "required": true
    },
    {
      "key": "MONGODB_URI",
      "title": "MongoDB Connection String",
      "description": "MongoDB connection string used to persist users, watchlists, and alerts.",
      "usage": "If missing, the bot still runs but watchlists and alerts are disabled.",
      "howToGet": "Use MongoDB Atlas or a managed MongoDB provider and copy the connection string.",
      "example": "mongodb+srv://user:pass@cluster.example.mongodb.net/mydb",
      "isSecret": true,
      "required": false
    },
    {
      "key": "COIN_API_BASE_URL",
      "title": "Market Data API Base URL",
      "description": "Base URL for the market data provider (default: CoinGecko v3).",
      "usage": "Used by MarketDataService for price and symbol list requests.",
      "howToGet": "Optional. Leave default unless you are using a proxy/mirror.",
      "example": "https://api.coingecko.com/api/v3",
      "isSecret": false,
      "required": false
    },
    {
      "key": "CACHE_TTL_MS",
      "title": "Price Cache TTL (ms)",
      "description": "How long price results are cached per symbol to reduce API calls.",
      "usage": "Used by MarketDataService for in-memory caching.",
      "howToGet": "Optional tuning parameter.",
      "example": "30000",
      "isSecret": false,
      "required": false
    },
    {
      "key": "POLL_INTERVAL_MS",
      "title": "Alert Polling Interval (ms)",
      "description": "How often the bot checks active alerts and sends notifications when targets are hit.",
      "usage": "Used by the in-process alert poller loop.",
      "howToGet": "Optional tuning parameter.",
      "example": "45000",
      "isSecret": false,
      "required": false
    },
    {
      "key": "LOG_LEVEL",
      "title": "Log Level",
      "description": "Controls logging verbosity.",
      "usage": "Used by src/lib/log.js to filter logs.",
      "howToGet": "Optional tuning parameter.",
      "example": "info",
      "isSecret": false,
      "required": false
    }
  ],
  "commandDocs": [
    {
      "command": "/start",
      "description": "Welcome message plus inline menu for Price Lookup, Watchlist, Alerts, and Help.",
      "usage": "/start",
      "examples": [
        "User: /start → Bot: Welcome message + buttons"
      ],
      "notes": "If MONGODB_URI is not set, the bot will mention that watchlists and alerts are disabled."
    },
    {
      "command": "/help",
      "description": "Shows all commands with examples and explains polling-based alert behavior.",
      "usage": "/help",
      "examples": [
        "User: /help → Bot: command list + examples"
      ],
      "notes": "Matches the implemented public commands."
    },
    {
      "command": "/price",
      "description": "Fetches current USD price and 24h percent change for a symbol and shows inline actions.",
      "usage": "/price BTC",
      "examples": [
        "User: /price BTC → Bot: price + change + buttons"
      ],
      "notes": "If the market API is down, the bot replies with a consistent fallback message (or cached data if available)."
    },
    {
      "command": "/watchlist",
      "description": "Lists or updates your watchlist.",
      "usage": "/watchlist | /watchlist add BTC | /watchlist remove BTC",
      "examples": [
        "User: /watchlist → Bot: list of symbols + remove buttons",
        "User: /watchlist add ETH → Bot: confirmed + updated list"
      ],
      "notes": "Requires MONGODB_URI."
    },
    {
      "command": "/alerts",
      "description": "Lists your alerts and provides inline remove buttons.",
      "usage": "/alerts",
      "examples": [
        "User: /alerts → Bot: alert list with short ids + remove buttons"
      ],
      "notes": "Requires MONGODB_URI."
    },
    {
      "command": "/alert",
      "description": "Adds or removes a price alert.",
      "usage": "/alert add BTC above 70000 | /alert add ETH below 2000 | /alert remove <alertId>",
      "examples": [
        "User: /alert add BTC above 70000 → Bot: Alert created: 3f9a12c1",
        "User: /alert remove 65d4b2f3c9a0f0c2f91d8a11 → Bot: Alert removed."
      ],
      "notes": "Alerts trigger once and are kept as history by marking status=triggered."
    },
    {
      "command": "/reset",
      "description": "Clears your watchlist and alerts.",
      "usage": "/reset",
      "examples": [
        "User: /reset → Bot: Done. Your watchlist and alerts were cleared."
      ],
      "notes": "Requires MONGODB_URI."
    }
  ]
}